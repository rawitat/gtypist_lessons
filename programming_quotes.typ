# Lesson for GNU Typist (gtypist)
# Inspired by built-in S2 lesson
#
# This lesson was written by Dave Rawitat Pulam
#

# The main menu
*:MENU
B:The Programming and Programming Languages Quotes Course
M:"The Programming Quotes series contains the following lessons"
 :GENERAL       "General Wisdoms                Wisdoms in Programming and Code Writing"
 :GENERAL_2     "General Wisdoms #2             Continuation of the above"
 :GENERAL_3     "General Wisdoms #3             Yet another continuation from above"
 :GENERAL_4     "General Wisdoms #4             You know the drill, from the above"
 :GENERAL_5     "General Wisdoms #5             Yet another one of the above"
 :GENERAL_6     "General Wisdoms #6             As the name said"
 :GENERAL_7     "General Wisdoms #7             As the name said, again"
 :PHILOSOPHY    "Philosophy of Computing        Man, Mind, Machine, etc"
 :PHILOSOPHY_2  "Philosophy of Computing #2     Continuation from aboove"
 :MACHINE_INT   "Machine Intelligence           Machine, Artificial, and Intelligence in General"
 :SW_ENG        "Software Engineering           Some thoughts on Software Dev/Eng"
 :SW_ENG_2      "Software Engineering #2        Continuation of the above"
 :SW_ENG_3      "Software Engineering #3        Just like that, from above"
 :SW_ENG_4      "Software Engineering #4        Just like that, from above"
 :OPTMZ_1       "Optimization                   Concerning Performance and optimization"
 :ELEM_PRG      "Elements of Programming Style  Lessons from legendary 1974 book"
 :UNIX_PRG      "The Art of Unix Programming    Quotes from another legendary book"
 :LISP          "Lisp and FP                    Lisp and Functional Programming"
 :LISP_2        "Lisp and FP #2                 Continuation of the above"
 :C_CPP         "C, C++, Objective-C            C and its family (C++, Obj-C)"
 :JAVACS        "Java and C#                    Java and C#, they belongs together"
 :DY_SCRIPT     "Dynamic Scripting              Perl, Ruby, Python, etc."
 :OOP           "Object-Oriented                OO Designs and implementation in Languages"
 :LEGACY        "Older, Legacy Languages        COBOL, Fortran, etc"
 :FUNNY         "Facts & Funny                  Facts & Funny about Programmers"


# ###########################################################################

*:GENERAL
B:General Wisdoms in Programming and Code Writing

*:G_1
I:[1] Abelson & Sussman, SICP, preface to the 1st edition
S:First, we want to establish the idea that a computer language is not just
 :a way of getting a computer to perform operations but rather that it is a
 :novel formal medium for expressing ideas about methodology.
 :
 :Thus, programs must be written for people to read, and only incidentally
 :for machines to execute.

*:G_2
I:[2] George Boole, quoted in Iverson's Turing Award Lecture
S:That language is an instrument of human reason, and not
 :merely a medium for the expression of thought, is a truth
 :generally admitted.

*:G_3
I:[3] Olin Shivers
S:I object to doing things that computers can do.

*:G_4
I:[4] Cyril Connolly
S:Imprisoned in every fat man a thin man is wildly signaling
 :to be let out.

*:G_5
I:[5] Kernighan and Ritchie
S:The only way to learn a new programming language is by
 :writing programs in it.

*:G_6
I:[6] Dave Moon
S:Language designers are not intellectuals.  They're not as
 :interested in thinking as you might hope.  They just want to
 :get a language done and start using it.

*:G_7
I:[7] Guy Steele
S:The continuation that obeys only obvious stack semantics,
 :O grasshopper, is not the true continuation.

*:G_8
I:[8] Jon Bentley and Doug McIlroy
S:The key to performance is elegance, not battalions of
 :special cases.

*:G_9
I:[9] Alan Kay
S:Don't worry about what anybody else is going to do.
 :The best way to predict the future is to invent it.

*:G_10
I:[10] Linus Torvalds
S:Talk is cheap.  Show me the code.

*:G_11
I:[11] Why The Lucky Stiff
S:When you don't create things, you become defined by your tastes
 :rather than ability.  Your tastes only narrow & exclude people.
 :So create.

*:G_12
I:[12] John Woods
S:Always code as if the guy who ends up maintaining your code will be
 :a violent psychopath who knows where you live.

*:G_13
I:[13] Martin Fowler
S:Any fool can write code that a computer can understand.  Good programmers
 :write code that humans can understand.

*:G_14
I:[14] Donald E. Knuth, "Selected Papers on Computer Science"
S:The best programs are written so that computing machines can perform
 :them quickly and so that human beings can understand them clearly.
 :A programmer is ideally an essayist who works with traditional aesthetic
 :and literary forms as well as mathematical concepts, to communicate
 :the way that an algorithm works and to convince a reader that the results
 :will be correct.

*:G_15
I:[15] Kent Beck
S:I'm not a great programmer; I'm just a good programmer with great habits.

*:G_16
I:[16] Robert C. Martin, "Clean Code"
S:Truth can only be found in one place: the code.

*:G_17
I:[17] Muhammad Waseem
S:Give a man a program, frustrate him for a day.
 :Teach a man to program, frustrate him for a lifetime.

*:G_18
I:[18] Alan J. Perlis
S:A language that doesn't affect the way you think about programming
 :is not worth knowing.

*:G_19
I:[19] Edward V. Berard
S:Walking on water and developing software from a specification
 :are easy if both are frozen.

*:G_20
I:[20] Alan Kay
S:The most disastrous thing that you can ever learn is your first
 :programming language.

*:G_21
I:[21] Joseph Weizenbaum
S:The computer programmer is a creator of universes for which
 :he alone is the lawgiver.  No playwright, no stage director, no
 :emperor, however powerful, has ever exercised such absolute
 :authority to arrange a stage or field of battle and to command
 :such unswervingly dutiful actors or troops.

*:G_22
I:[22] C.A.R Hoare
S:The most important property of a program is whether it accomplishes
 :the intention of its user.

*:G_23
I:[23] Marvin Minsky
S:A computer is like a violin.  You can imagine a novice trying first
 :a phonograph and then a violin.  The latter, he says, sounds terrible.
 :That is the argument we have heard from our humanists and most of our
 :computer scientists.  Computer programs are good, they say, for
 :particular purposes, but they aren't flexible.  Neither is a violin,
 :a typewriter, until you learn how to use it.

*:G_24
I:[24] Robert C. Martin
S:Remember that code is really the language in which we ultimately
 :express the requirements.  We may create languages that are closer
 :to the requirements.  We may create tools that help us parse and
 :assemble those requirements into formal structures.  But we will
 :never eliminate necessary precision - so there will always be code.

*:G_25
I:[25] Eric Raymond
S:Computer science education cannot make anybody an expert programmer
 :any more than studying brushes and pigment can make somebody an
 :expert painter.

*:G_26
I:[26] L. Peter Deutsch
S:To iterate is human, to recurse is divine.

*:G_27
I:[27] Anonymous
S:The best thing about a boolean is even if you are wrong, you are
 :only off by a bit.

*:G_28
I:[28] Bjarne Stroustrup
S:There are only two kinds of programming languages: those people always
 :bitch about and those nobody uses.

*:G_29
I:[29] Brian Kernighan
S:Controlling complexity is the essence of computer programming.

*:G_30
I:[30] Edsger W. Dijkstra
S:Progress is possible only if we train ourselves to think about programs
 :without thinking of them as pieces of executable code.

*:G_31
I:[31] Steve Jobs
S:Everybody in this country should learn to program a computer, because
 :it teaches you how to think.

*:G_32
I:[32] C.A.R Hoare
S:The code is like humor: When you have to explain it, it's bad.

*:G_33
I:[33] Why The Lucky Stiff
S:Programming is rather thankless.  You see your works become replaced by
 :superior ones in a year, unable to run at all in a few more.

*:G_34
I:[34] Alan J. Perlis
S:When someone says: "I want a programming language in which I need only say
 :what I wish done", give him a lollipop.

*:G_35
I:[35] Alan J. Perlis
S:A programming language is low-level when its programs require attention
 :to the irrelevant.

*:G_36
I:[36] Alan J. Perlis
S:The best book on programming for the layman is 'Alice in Wonderland';
 :but that's because it's the best book on anything for the layman.
 
*:G_37
I:[37] Donald Knuth
S:Everyday life is like programming, I guess.
 :If you love something you can put beauty into it.

*:G_38
I:[38] Paul Graham
S:A programming language is for thinking about programs, not for expressing
 :programs you've already thought of.  It should be a pencil, not a pen.

Q:Do you want to continue to next lesson [Y/N] ? 
N:MENU

# ###########################################################################

*:GENERAL_2
B:General Wisdoms in Programming and Code Writing #2

*:G2_1
I:[1] Kernighan & Plauger, "The Elements of Programming Style"
S:Trying to outsmart a compiler defeats much of the purpose of using one.

*:G2_2
I:[2] Henry Spencer
S:If you lie to the compiler, it will have its revenge.

*:G2_3
I:[3] Bell Labs saying
S:Some languages are designed to solve a problem.
 :Others are designed to prove a point.

*:G2_4
I:[4] Ken Thompson
S:When in doubt, use brute force.

*:G2_5
I:[5] John F. Kennedy
S:Man is still the most extraordinary computer of all.

*:G2_6
I:[6] B.F. Skinner
S:The real problem is not whether machines think but whether men do.

*:G2_7
I:[7] Jeff Scholnik
S:Who cares how it works, just as long as it gives the right answer?

*:G2_8
I:[8] Bill Gates
S:The first rule of any technology used in a business is that automation
 :applied to an efficient operation will magnify the efficiency.
 :The second is that automation applied to an inefficient operation will
 :magnify the inefficiency.

*:G2_9
I:[9] Andrew Orlowski
S:See, no matter how clever your automation systems might be, it all falls
 :apart if your human wetware isn't up to the job.

*:G2_10
I:[10] John Backus
S:I think conventional languages are for the birds.  They're just extensions of
 :the von Neumann computer, and they keep our noses in the dirt of dealing with
 :individual words and computing addresses, and doing all kinds of silly things
 :like that, things that we've picked up from programming for computers; we've
 :built them into programming languages; we've built them into Fortran; we've
 :built them into PL/I; we've built them into almost every language.

*:G2_11
I:[11] Aristophanes
S:High thoughts must have a high language.

*:G2_12
I:[12] Ted Nelson
S:Learning to program has no more to do with designing interactive software
 :than learning to touch type has to do with writing poetry.

*:G2_13
I:[13] Donald E. Knuth
S:People think that computer science is the art of geniuses but the actual
 :reality is the opposite, just many people doing things that build on each
 :other, like a wall of mini stones.

*:G2_14
I:[14] Peter Van Roy, Seif Haridi
S:The most difficult work of programmers, and also the most rewarding, is not
 :writing programs but rather designing abstractions.

*:G2_15
I:[15] Edsger W. Dijkstra
S:Besides a mathematical inclination, an exceptionally good mastery of one's
 :native tongue is the most vital asset of a competent programmer.

*:G2_16
I:[16] Paul Graham, "Beating the Averages"
S:Ordinary technology changes fast.  But programming languages are different:
 :Programming languages are not just technology, but what programmers think in.
 :They're half technology and half religion.  And so the median language, meaning
 :whatever language the median programmer uses, moves as slow as an iceberg.

*:G2_17
I:[17] Alan J. Perlis
S:The computers are never large enough or fast enough.  Each breakthrough in
 :hardware technology leads to more massive programming enterprises, new
 :organizational principles, and an enrichment of abstract models.  Every reader
 :should ask himself periodically "Toward what end, toward what end?" - but do
 :not ask it too often lest you pass up the fun of programming for the
 :constipation of bittersweet philosophy.

*:G2_18
I:[18] Kent Beck, "Test-Driven Development"
S:Paradox: by not considering the future of your code, you make your code much
 :more likely to be adaptable in the future.

*:G2_19
I:[19] Edsger W. Dijkstra
S:Software Engineering is Programming when you can't.
 :We must give industry not what it wants, but what it needs.

*:G2_20
I:[20] Edsger W. Dijkstra
S:Another series of [philosopher's] stone in the form of "programming tools" is
 :produced under the banner of "software engineering", which, as time went by,
 :has sought to replace intellectual discipline by management discipline to the
 :extent that it has now accepted as its charter "How to program if you cannot".

*:G2_21
I:[21] Curtis Poe, "Finding Technology Solutions"
S:Technology is part of the answer, not part of the question.  Don't make choices
 :only to then try to figure out how to twist the problem in such a way so as to
 :fit your choice.  This will often result in your solution being more convoluted
 :than my previous sentence.

*:G2_22
I:[22] Frederick P. Brooks, Jr., "The Mythical Man-Month"
S:In fact, flow charting is more preached than practiced.  I have never seen an
 :experienced programmer who routinely made detailed flow charts before beginning
 :to write programs.  Where organization standards require flow charts, these
 :are almost invariably done after the fact.  Many shops proudly use machine
 :programs to generate this "indispensable design tool" from the completed code.
 :I think this universal experience is not an embarassing and deplorable
 :departure from good practice, to be acknowledged only with a nervous laugh.
 :Instead it is the application of good judgement, and it teaches us something
 :about the utility of flow charts.

*:G2_23
I:[23] D. Gelernter, "Machine Beauty"
S:Beauty is more important in computing than anywhere else in technology because
 :software is so complicated.  Beauty is the ultimate defense against complexity.
 :The geniuses of the computer field, on the other hand, are the people with
 :keenest aesthetic senses, the ones who are capable of creating beauty.  Beauty
 :is decisive at every level: the most important interfaces, the most important
 :programming languages, the winning algorithms are the beautiful ones.

*:G2_24
I:[24] D. Gelernter, "Machine Beauty"
S:Good programmers know what's beautiful and bad ones don't.

*:G2_25
I:[25] Paul Graham
S:A really good language should be both clean and dirty: cleanly designed, with
 :a small core of well understood and highly orthogonal operators, but dirty in
 :the sense that it lets hackers have their way with it.
 :
 :A real hacker's language will always have a slightly raffish character.

*:G2_26
I:[26] Paul Graham
S:Fixing fresh bugs is easier than fixing old ones.  It's usually fairly quick
 :to find a bug in code you just wrote.  When it turns up you often know what's
 :wrong before you even look at the source, because you were already worrying
 :about it subconsciously.  Fixing a bug in something you wrote six months ago
 :(the average case if you release once a year) is a lot more work.  And since
 :you don't understand the code as well, you're more likely to fix it in an ugly
 :way, or even introduce more bugs.

*:G2_27
I:[27] Paul Graham
S:When you catch bugs early, you also get fewer compounded bugs.  Compounded
 :bugs are two separate bugs that interact: you trip going downstairs, and when
 :you reach for the handrail it comes off in your hand.  In software this kind of
 :bug is the hardest to find, and also tends to have the worst consequences.
 :The traditional "break everything and then filter out the bugs" approach
 :inherently yields a lot of compound bugs.  And software released in a series
 :of small changes inherently tends not to.  The floors are constantly being
 :swept clean of any loose objects that might later get stuck to something.

*:G2_28
I:[28] Paul Graham
S:The way to make programs easy to read is not to stuff them with comments.
 :A good programming language ought to be better for explaining software than
 :English.  You should only need comments when there is some kind of kludge
 :you need to warn readers about, just as on a road there are only arrows on
 :parts with unexpected sharp curves.

*:G2_29
I:[29] R. Hamming
S:The purpose of computing is insight, not numbers.

*:G2_30
I:[30] S. Heller, in "Efficient C/C++ Programming"
S:The speed of a non-working program is irrelevant.

*:G2_31
I:[31] G.H. Hardy, in "A Mathematician's Apology"
S:Beauty is the first test: there is no permanent place in this world for
 :ugly mathematics.

*:G2_32
I:[32] C.A.R Hoare
S:I was eventually persuaded of the need to design programming notations so as
 :to maximize the number of errors which cannot be made, or if made, can be
 :reliably detected at compile time.

*:G2_33
I:[33] C.A.R Hoare
S:In the development of the understanding of complex phenomena, the most powerful
 :tool available to the human intellect is abstraction.  Abstraction arises from
 :recognition of similarities between certain objects, situations, or processes
 :in the real world and the decision to concentrate on these similarities and to
 :ignore, for the time being, their differences.

*:G2_34
I:[34] C.A.R Hoare
S:Inside every well-written large program is a well-written small program.

*:G2_35
I:[35] D. Hock (founder of VISA)
S:The problem is never how to get new, innovative thoughts into your mind, but
 :how to get old ones out!

Q:Do you want to continue to next lesson [Y/N] ? 
N:MENU


# ###########################################################################

*:GENERAL_3
B:General Wisdoms in Programming and Code Writing #3

*:G3_1
I:[1] D. Jones
S:The fastest algorithm can frequently be replaced by one that is almost as fast
 :and much easier to understand.

*:G3_2
I:[2] Alan Kay
S:90% of code written today is getting around other people's mistakes.

*:G3_3
I:[3] Alan Kay
S:Computers are to computing as instruments are to music.  Software is the
 :score whose interpretations amplifies our reach and lifts our spirits.
 :Leonardo da Vinci called music the shaping of the invisible, and his phrase
 :is even more apt as a description of software.

*:G3_4
I:[4] Alan Kay
S:[In a programming language] Simple things should be simple and complex things
 :should be possible.

*:G3_5
I:[5] Donald E. Knuth
S:Computers are good at following instructions, but not at reading your mind.

*:G3_6
I:[6] Donald E. Knuth
S:Let us change our traditional attitude to the construction of programs.
 :Instead of imagining that our main task is to instruct a computer what to do,
 :let us concentrate rather on explaining to human beings what we want a
 :computer to do.

*:G3_7
I:[7] Donald E. Knuth
S:Programmers waste enormous amounts of time thinking about, or worrying about,
 :the speed of noncritical parts of their programs, and these attempts at
 :efficiency actually have a strong negative impact when debugging and
 :maintenance are considered.  We should forget about small efficiencies, say
 :about 97% of the time: premature optimization is the root of all evil.  Yet
 :we should not pass up our opportunities in that critical 3%.

*:G3_8
I:[8] J. von Neumann
S:In mathematics you don't understand things.  You just get used to them.

*:G3_9
I:[9] Alan J. Perlis
S:I think that it's extraordinary important that we in computer science keep fun
 :in computing.  When it started out, it was an awful lot of fun.  Of course,
 :the paying customers got shafted every now and then, and after a while we began
 :to take their complaints seriously.  We began to feel as if we really were
 :responsible for the successful, error-free perfect use of these machines.
 :I don't think we are.  I think we're responsible for stretching them, setting
 :them off in new directions, and keeping fun in the house.  I hope the field
 :of computer science never loses its sense of fun.

*:G3_10
I:[10] Alan J. Perlis
S:It goes against the grain of modern education to teach students to program.
 :What fun is there to making plans, acquiring discipline, organizing thoughts,
 :devoting attention to detail, and learning to be self critical.

*:G3_11
I:[11] Alan J. Perlis
S:It is easier to write an incorrect program than understand a correct one.

*:G3_12
I:[12] Alan J. Perlis
S:Optimization hinders evolution.  Everything should be built top-down, except the
 :first time.  Simplicity does not precede complexity, but follows it.

*:G3_13
I:[13] Alan J. Perlis
S:To understand a program, you must become both the machine and the program.

*:G3_14
I:[14] Bjarne Stroustrup
S:Design and programming are human activities; forget that and all is lost.

*:G3_15
I:[15] Alan Turing
S:We shall do much better programming job, provided we approach the task with
 :a full appreciation of its tremendous difficulty, provided that we respect
 :the intrinsic limitations of the human mind and approach the task as very
 :humble programmers.

*:G3_16
I:[16] S. McConnell
S:Good code is its own best documentation.  As you're about to add a comment,
 :ask yourself "How can I improve the code so that this comment isn't needed?"
 :Improve the code and then document it to make it even clearer.

*:G3_17
I:[17] Alan J. Perlis
S:A good programming language is a conceptual universe for thinking about
 :programming.

*:G3_18
I:[18] Alan J. Perlis
S:Fools ignore complexity; pragmatists suffer it; experts avoid it;
 :geniuses remove it.

*:G3_19
I:[19] Alan J. Perlis
S:I think it is inevitable that people program poorly.  Training will not
 :substantially help matters.  We have to learn to live with it.

*:G3_20
I:[20] E.B. White
S:The best writing is rewriting.

*:G3_21
I:[21] L. Wittenstein
S:The limits of your language are the limits of your world.

*:G3_22
I:[22] W. Wulf
S:More bugs have been introduced into programs through premature optimization
 :than any other cause, including pure stupidity.
 :
 :(Sometimes quoted as:)
 :More computing sins are committed in the name of efficiency, without 
 :necessarily achieving it, than for any other single reason - including
 :blind stupidity.

*:G3_23
I:[23] E.C. Zeeman
S:Technical skill is mastery of complexity,
 :while creativity is mastery of simplicity.

*:G3_24
I:[24] Quincy Larson
S:Everyone needs computer programming.  It will be the way we speak to the
 :servants.

*:G3_25
I:[25] Linus Torvalds
S:Most good programmers do programming not because they expect to get paid or
 :get adulation by the public, but because it is fun to program.

*:G3_26
I:[26] Anonymous
S:Computers do not solve problems, they execute solutions.

*:G3_27
I:[27] Oscar Godson
S:One of the best programming skills you can have is knowing when to walk away
 :for awhile.

*:G3_28
I:[28] Scott Adams
S:You can never underestimate the stupidity of the general public.

*:G3_29
I:[29] Kreitzberg & Shmeiderman
S:Programming can be fun, so can cryptography;
 :however they should not be combined.

*:G3_30
I:[30] C.A.R Hoare
S:Inside every large program, there is a program trying to get out.

*:G3_31
I:[31] Pragmatic Programmer
S:A good way to stay flexible is to write less code.

*:G3_32
I:[32] Gerald M. Weinberg
S:No matter what the problem is, it's always a people problem.

*:G3_33
I:[33] Gordon Bell
S:Every big computing disaster has come from taking too many ideas and putting
 :them in one place.

*:G3_34
I:[34] Edsger W. Dijkstra
S:Simplicity is prerequisite for reliability.

*:G3_35
I:[35] Jordi Boggiano
S:Focus on WHY instead of WHAT in your code will make you a better developer.

*:G3_36
I:[36] Stewart Alsop
S:Gates is the ultimate programming machine.  He believes everything can be
 :defined, examined, reduced to essentials, and rearranged into a logical
 :sequence that will achieve a particular goal.

Q:Do you want to continue to next lesson [Y/N] ? 
N:MENU

# ###########################################################################

*:GENERAL_4
B:General Wisdoms in Programming and Code Writing #4

*:G4_1
I:[1] Andrei Herasimchuck
S:The best engineers I know are artists at heart.
 :The best designers I know are secretly technicians as well.

*:G4_2
I:[2] Donald E. Knuth
S:You're bound to be unhappy if you optimize everything.

*:G4_3
I:[3] Robert C. Martin
S:The proper use of comments is to compensate for our failure to express
 :ourself in code.

*:G4_4
I:[4] David Heinemeier Hansson
S:Programmers are constantly making things more complicated than they need to be
 :BECAUSE FUTURE.  Fuck the future.  Program for today.

*:G4_5
I:[5] Ron Fein
S:Design is choosing how you will fail.

*:G4_6
I:[6] Ron Jeffries
S:Code never lies, comments sometimes do.

*:G4_7
I:[7] Larry Wall
S:You want it in one line? Does it have to fit in 80 columns?

*:G4_8
I:[8] John Ousterhout
S:The best performance improvement is the transition from the nonworking state
 :to the working state.

*:G4_9
I:[9] Bjarne Stroustrup
S:An organization that treats its programmers as morons will soon have
 :programmers that are willing and able to act like morons only.

*:G4_10
I:[10] Niklaus Wirth
S:Prolific programmers contribute to certain disaster.

*:G4_11
I:[11] Anonymous
S:Every good work of software starts by scratching a developer's personal itch.

*:G4_12
I:[12] Ricard Pattis
S:Programming languages, like pizzas, come in only two sizes:
 :too big and too small.

*:G4_13
I:[13] Alan J. Perlis
S:One man's constant is another man's variable.

*:G4_14
I:[14] Anonymous
S:Only half of programming is coding.  The other 90% is debugging.

*:G4_15
I:[15] Steve McConnell
S:The big optimizations come from refining the high-level design, not the
 :individual routines.

*:G4_16
I:[16] Robert C. Martin
S:All race conditions, deadlock conditions, and concurrent update problems
 :are due to mutable variables.

*:G4_17
I:[17] Alan Turing
S:Up to a point, it is better to just let the snags [bugs] be there than to spend
 :such time in design that there are none.

*:G4_18
I:[18] C.A.R Hoare
S:The price of reliability is the pursuit of the utmost simplicity.
 :It is a price which the very rich may find hard to pay.

*:G4_19
I:[19] C.A.R Hoare
S:You cannot teach beginners top-down programming, because they don't know
 :which end is up.

*:G4_20
I:[20] Edsger W. Dijkstra
S:The competent programmer is fully aware of the strictly limited size of his
 :own skull; therefore he approaches the programming task in full humility, and
 :among other things he avoids clever tricks like the plague.

*:G4_21
I:[21] Richard Pattis
S:If you cannot grok the overall structure of a program while taking a shower,
 :you are not ready to code it.

*:G4_22
I:[22] Kurt Vonnegut
S:If you can't write clearly, you probably don't think nearly as well as you think.

*:G4_23
I:[23] James Gosling
S:You never actually find a perfect answer to a problem.  You just find the
 :answer that has the fewest problems.

*:G4_24
I:[24] Nick Takayama
S:The hardest problem in computer science is not being an opinionated jerk
 :about everything.

*:G4_26
I:[26] Sam Morgan
S:Your code has two users: the computer, and every other person who has to work
 :with what you wrote.

*:G4_27
I:[27] Michael Feathers
S:In a complex system you don't get to change just one thing - ever.

*:G4_28
I:[28] Bjarne Stroustrup
S:More good code has been written in languages denounced as bad than in languages
 :proclaimed wonderful.

*:G4_29
I:[29] Eric Raymond
S:Smart data structures and dumb code works a lot better than
 :the other way around.

*:G4_30
I:[30] Dennis Ritchie
S:A language that doesn't have everything is actually easier to program
 :than some that do.

*:G4_31
I:[31] Edsger W. Dijkstra
S:... the purpose of abstraction is not to be vague, but to create a new semantic
 :level in which one can be absolutely precise.

*:G4_32
I:[32] B. Reid
S:Computer Science is the first engineering discipline in which the complexity
 :of the objects created is limited solely by the skill of the creator, and not
 :by the strength of raw materials.

*:G4_33
I:[33] Michael Feathers
S:We just have to accept that developer skill is a far more significant variable
 :than language choice or methodological nuances.

*:G4_34
I:[34] Martin Fowler
S:Comparing to another activity is useful if it helps you formulate questions,
 :it's dangerous when you use it to justify answers.

*:G4_35
I:[35] Alan J. Perlis
S:Every program has (at least) two purposes: the one for which it was written,
 :and another for which it wasn't.

*:G4_36
I:[36] Donald Knuth
S:The most important thing in the programming language is the name.  A language
 :will not succeed without a good name.  I have recently invented a very good
 :name and now I am looking for a suitable language.

Q:Do you want to continue to next lesson [Y/N] ? 
N:MENU

# ###########################################################################

*:GENERAL_5
B:General Wisdoms in Programming and Code Writing #5

*:G5_1
I:[1] Ron Jeffries
S:When we use a language, we should commit ourselves to knowing it, being able
 :to read it, and writing it idiomatically.

*:G5_2
I:[2] Steve McConnell
S:A brute force solution that works is better than an elegant solution that
 :doesn't work.

*:G5_3
I:[3] Alan J. Perlis
S:Syntactic sugar causes cancer of the semicolon, and other.

*:G5_4
I:[4] Edsger W. Dijkstra
S:The tools we use have a profound (and devious!) influence on our
 :thinking habits, and, therefore, on our thinking abilities.

*:G5_5
I:[5] Bjarne Stroustrup, "The Design and Evolution of C++"
S:There is no agreement of what a programming language really is
 :and what its main purpose is supposed to be.
 :
 :Is a programming language a tool for instructing machines?
 :A means of communicating between programmers?
 :A vehicle for expressing high-level designs?
 :A notation for algorithms?
 :A way of expressing relationships between concepts?
 :A tool for experimentation?
 :A means of controlling computerized devices?
 :
 :My view is that a general-purpose programming language must be all of those
 :to serve its diverse set of users.  The only thing a language cannot be
 :"and survive" is a mere collection of "neat" features.

*:G5_6
I:[6] Bjarne Stroustrup, "The Design and Evolution of C++"
S:It is my firm belief that all successful languages are grown and not merely
 :designed from first principles.

*:G5_7
I:[7] Bjarne Stroustrup, "The Design and Evolution of C++"
S:I have reaffirmed a long-standing and strongly held view: Language comparisons
 :are rarely meaningful and even less often fair.  A good comparison of major
 :programming languages requires more effort than most people are willing to
 :spend, experience in a wide range of application areas, a rigid maintenance
 :of a detached and impartial point of view, and a sense of fairness.

*:G5_8
I:[8] Bjarne Stroustrup, "LinuxWorld"
S:I think that any language that aspires to mainstream use must provide a broad
 :base for a variety of techniques -- including object-oriented programming
 :(class hierarchies) and generic programming (parameterized types and 
 :algorithms).  In particular, it must provide good facilities for composing
 :programs out of separate parts (possibly writing in several different
 :languages).  I also think that exceptions are necessary for managing the
 :complexity of error handling.  A language that lacks such facilities forces
 :its users to laboriously simulate them.

*:G5_9
I:[9] Dennis Ritchie, "LinuxWorld"
S:At least for the people who send me mail about a new language that they're
 :designing, the general advice is: do it to learn about how to write a compiler.
 :Don't have any expectations that anyone will use it, unless you hook up with
 :some sort of organization in a position to push it hard.  It's a lottery, and
 :some can buy a lot of the tickets.  There are plenty of beautiful languages
 :(more beautiful than C) that didn't catch on.  But someone does win the lottery,
 :and doing a language at least teaches you something.

*:G5_10
I:[10] Alan Kay, "Educom Review"
S:What doesn't exist are really powerful general forms of arguing with computers
 :right now.  So we have to have special orders coming in on special cases and
 :then think up ways to do it.  Some of these are generalizable and eventually you
 :will get an actual engineering discipline.

*:G5_11
I:[11] Abelson & Sussman, "SICP"
S:We have also obtained a glimpse of another crucial idea about languages and
 :program design.  This is the approach of stratified design, the notion that
 :a complex system should be structured as a sequence of levels that are described
 :using a sequence of languages.  Each level is constructed by combining parts
 :that are regarded as primitive at that level, and the parts constructed at each
 :level are used as primitives at the next level.  The language used at each level
 :of a stratified design has primitives, means of combination, and means of
 :abstraction appropriate to that level of detail.

*:G5_12
I:[12] Simon Peyton Jones
S:In the programming-language world, one rule of survival is simple: dance or die.
 :It is not enough to make a beautiful language.  You must also make it easy for
 :programs written in your beautiful language to interact with programs written in
 :other languages.

*:G5_13
I:[13] John McCarthy, "Towards a Mathematical Science of Computation"
S:Let me re-assert that the question of whether there are limitations in
 :principle of what problems man can make machines solve for him as compared
 :to his own ability to solve problems, really is a technical question in
 :recursive function theory.

*:G5_14
I:[14] Kent Beck
S:The craft of programming begins with empathy, not formatting or languages or
 :tools or algorithms or data structures.

*:G5_15
I:[15] Edsger W. Dijkstra
S:Simplicity and elegance are unpopular because they require hard work and
 :discipline to achieve and education to be appreciated.

*:G5_16
I:[16] Edsger W. Dijkstra
S:The question of whether computers can think is like the question of whether
 :submarines can swim.

*:G5_17
I:[17] Ken Thompson
S:You can't trust code that you did not totally create yourself.

*:G5_18
I:[18] Leonardo da Vinci
S:Simplicity is the ultimate sophistication.

*:G5_19
I:[19] Niklaus Wirth
S:Increasingly, people seem to misinterpret complexity as sophistication, which
 :is baffling -- the incomprehensible should cause suspicion rather than admiration.
 :Possibly this trend results from a mistaken belief that using a somewhat
 :mysterious device confers an aura of power on the user.

*:G5_20
I:[20] Chris Wenham
S:Debugging time increases as a square of the program's size.

*:G5_21
I:[21] P.J. Plauger
S:My definition of an expert in any field is a person who knows enough about
 :what's really going on to be scared.

*:G5_22
I:[22] Richard Gabriel
S:Old programs read like quiet conversations between a well-spoken research
 :worker and a well-studied mechanical colleague, not as a debate with a compiler.
 :Who'd have guessed sophistication bought such noise?

*:G5_23
I:[23] R. Buckminster Fuller
S:When I am working on a problem I never think about beauty.  I think only how to
 :solve the problem.  But when I have finished, if the solution is not beautiful,
 :I know it is wrong.

*:G5_24
I:[24] Linus Torvalds
S:I will, in fact, claim that the difference between a bad programmer and a good
 :one is whether he considers his code or his data structures more important.
 :Bad programmers worry about the code.  Good programmers worry about data
 :structures and their relationships.

*:G5_27
I:[27] Hans Hoffmann
S:The ability to simplify means to eliminate the unnecessary so that
 :the necessary may speak.

*:G5_28
I:[28] John von Neumann
S:There's no sense being exact about something if you don't even know
 :what you're talking about.

*:G5_29
I:[29] Paul Graham
S:In programming the hard part isn't solving problems, but deciding
 :what problems to solve.

*:G5_30
I:[30] Rob Pike
S:Such is modern computing: everything simple is made too complicated because
 :it's easy to fiddle with; everything complicated stays complicated because
 :it's hard to fix.

*:G5_31
I:[31] Christer Ericson
S:Premature optimization, that's like a sneeze.
 :Premature abstraction is like ebola; it makes my eyes bleed.

*:G5_32
I:[32] John Romero
S:You might not think programmers are artists, but programming is an extremely
 :creative profession.  It's logic-based creativity.

*:G5_33
I:[33] Ellen Ullman
S:Programming is the art of algorithm design and the craft of debugging
 :errant code.

*:G5_34
I:[34] Edsger W. Dijkstra
S:Programming is one of the most difficult branches of applied mathematics;
 :the poorer mathematicians had better remain pure mathematicians.

Q:Do you want to continue to next lesson [Y/N] ? 
N:MENU

# ###########################################################################

*:GENERAL_6
B:General Wisdoms in Programming and Code Writing #6

*:G6_1
I:[1] John Carmack
S:Programming is not a zero-sum game.  Teaching something to a fellow programmer
 :doesn't take it away from you.  I'm happy to share what I can, because I'm in it
 :for the love of programming.

*:G6_2
I:[2] John Maeda
S:There is a construct in computer programming called 'the infinite loop' which
 :enables a computer to do what no other physical machine can do - to operate in
 :perpetuity without tiring.  In the same way it doesn't know exhaustion, it doesn't
 :know when it's wrong and it can keep doing the wrong thing over and over without
 :tiring.

*:G6_3
I:[3] Ryan Bethencourt
S:I imagine a day, some time in the not too distant future when children and
 :teenagers will be able to create their own genetically engineered machines,
 :cure the diseases of the old and find new ways to build and extend capabilities
 :of humanity, moving from programming software to programming the physical world,
 :through biology.

*:G6_4
I:[4] Mark Cuban
S:I personally think there's going to be a greater demand in 10 years for liberal arts
 :majors than there were for programming majors and maybe even engineering, because
 :when the data is all being spit out for you, options are being spit out for you,
 :you need a different perspective in order to have a different view of the data.

*:G6_5
I:[5] Niklaus Wirth
S:Many people tend to look at programming styles and languages like religions:
 :if you belong to one, you cannot belong to others.  But this analogy is
 :another fallacy.

*:G6_6
I:[6] Ellen Ullman
S:Computer programming has always been a self-taught, maverick occupation.

*:G6_7
I:[7] Nicholas Negroponte
S:Giving the kids a programming environment of any sort, whether it's a tool like
 :Squeak or Scratch or Logo to write programs in a childish way - and I mean that
 :in the most generous sense of the word, that is, playing with and building
 :things - is one of the best ways to learn.

*:G6_8
I:[8] Niklaus Wirth
S:Programming is usually taught by examples.

*:G6_9
I:[9] Niklaus Wirth
S:Our ultimate goal is Extensible Programming (EP).  By this, we mean the
 :construction of hierarchies of modules, each module adding new functionality
 :to the system.

*:G6_10
I:[10] Marc Andreessen
S:An awful lot of successful technology companies ended up being in a slightly
 :different market than they started out.  Microsoft started with programming tools,
 :but came out with an operating system.  Oracle started doing contracts for the CIA.
 :AOL started out as an online video gaming network.

*:G6_11
I:[11] Alan J. Perlis
S:In English every word can be verbed.  Would that it were so in our programming
 :language.

*:G6_12
I:[12] William Mougayar
S:Study how to write smart contracts, which is the basic unit of programming
 :a blockchain for business purposes.  It is the equivalent of being taught HTML
 :and Java during the early Internet days.  And master how to create assets or
 :tokenize existing ones on a blockchain.

*:G6_13
I:[13] Tim O'Reilly
S:There is people who make stuff with words.  There is people who make stuff with
 :programs.  And I really believe that that whole creative culture, people didn't
 :realize how creative programming is.  And anybody who's done it of course knows
 :that not only is it creative, but it's incredibly absorbing.

*:G6_14
I:[1] Maya Lin
S:I loved logic, math, computer programming.  I loved systems and logic approaches.
 :And so I just figured architecture is this perfect combination.

*:G6_15
I:[15] Masi Oka
S:Coming from a programming background, I have a good sense of what's feasible
 :and what's not feasible in a game.

*:G6_16
I:[16] Craig Federighi
S:People sometimes have a view of programming that is something solitary and very
 :technical.  But programming is among the most creative, expressive, and social
 :careers.

*:G6_17
I:[17] Geoff Mulgan
S:Courses can, and should, incorporate the excitement and fun of programming games,
 :apps or even real digital devices.

*:G6_18
I:[18] Bill Gates
S:In a budget, how important is art versus music versus athletics versus computer
 :programming? At the end of the day, some of those trade-offs will be made
 :politically.

*:G6_19
I:[19] Alan J. Perlis
S:Some programming languages manage to absorb change, but withstand progress.

*:G6_20
I:[20] Bjarne Stroustrup
S:I find languages that support just one programming paradigm constraining.

*:G6_21
I:[21] Niklaus Wirth
S:But active programming consists of the design of new programs, rather than
 :contemplation of old programs.

*:G6_22
I:[22] Niklaus Wirth
S:Clearly, programming courses should teach methods of design and construction,
 :and the selected examples should be such that a gradual development can be
 :nicely demonstrated.

*:G6_23
I:[23] Brian Kernighan
S:Programming language is very specific to instructing a computer to do a particular
 :structure of sequence.  It's the very way you tell the machine what you want it
 :to do.

*:G6_24
I:[24] Jeff Minter
S:I always considered programming as being like modern-day wizardry.  You could think
 :of things in your mind and then make them happen.

*:G6_25
I:[25] Ellen Ullman
S:People imagine that programming is logical, a process like fixing a clock.
 :Nothing could be further from the truth.

*:G6_26
I:[26] Ellen Ullman
S:Productivity has always been the justification for the prepackaging of programming
 :knowledge.  But it is worth asking about the sort of productivity gains that come
 :from the simplifications of click-and-drag.

*:G6_27
I:[27] Leslie Lamport
S:There is a race between the increasing complexity of the systems we build and our
 :ability to develop intellectual tools for understanding that complexity.  If the race
 :is won by our tools, then systems will eventually become easier to use and more
 :reliable.  If not, they will continue to become harder to use and less reliable for
 :all but a relatively small set of common tasks.  Given how hard thinking is, if those
 :intellectual tools are to succeed, they will have to substitute calculation for
 :thought.

*:G6_28
I:[28] W. Edwards Deming
S:Sub-optimization is when everyone is for himself.  Optimization is when everyone
 :is working to help the company.

*:G6_29
I:[29] Mark Zuckerberg
S:The biggest risk is not taking any risk.  In a world that changing really quickly,
 :the only strategy that is guaranteed to fail is not taking risks.

*:G6_30
I:[30] Henry Petroski
S:The most amazing achievement of the computer software industry is its continuing
 :cancellation of the steady and staggering gains made by the computer hardware
 :industry.

*:G6_31
I:[31] Timm Martin
S:True innovation often comes from the small startup who is lean enough to launch
 :a market but lacks the haft to own it.

*:G6_32
I:[32] Larry Wall
S:Computer language design is just like a stroll in the park.  Jurassic Park, that is.

*:G6_33
I:[33] David Emery
S:The only people who have anything to fear from free software are those whose products
 :are worth even less.

*:G6_34
I:[34] Maurice Wilkes
S:As soon as we started programming, we found to our surprise that it wasn't as easy
 :to get programs right as we had thought.  Debugging had to be discovered.  I can
 :remember the exact instant when I realized that a large part of my life from then on
 :was going to be spent in finding mistakes in my own programs.

*:G6_35
I:[35] David Wheeler
S:All problems in computer science can be solved by another level of indirection.
 :
 :(Related) But that usually will create another problem.

*:G6_36
I:[36] Joel Spolsky
S:It's harder to read code than to write it.

Q:Do you want to continue to next lesson [Y/N] ? 
N:MENU

# ###########################################################################

*:GENERAL_7
B:General Wisdoms in Programming and Code Writing #7

*:G7_1
I:[1] Dennis Ritchie
S:UNIX is simple.  It just takes a genius to understand its simplicity.

*:G7_2
I:[2] Jamie Zawinski
S:Some people, when confronted with a problem, think 'I know, I'll use regular
 :expressions.'  Now they have two problems.

*:G7_3
I:[3] Douglas Adams (about Y2K)
S:I really didn't foresee the Internet.  But then, neither did the computer industry.
 :Not that that tells us very much of course -- the computer industry didn't even
 :foresee that the century was going to end.

*:G7_4
I:[4] Nicholas Negroponte
S:Computing is not about computers any more.  It is about living.

*:G7_5
I:[5] Danielle Berry
S:No one ever said on their deathbed, "Gee, I wish I had spent more time alone
 :with my computer".

*:G7_6
I:[6] Adam Osborne
S:People think computers will keep them from making mistakes.  They're wrong.
 :With computers you make mistakes faster.

*:G7_7
I:[7] Steve Jobs
S:Computers themselves, and software yet to be developed, will revolutionize
 :the way we learn.

*:G7_8
I:[8] Norman Ralph Augustine
S:One of the most feared expressions in modern times is "The computer is down".

*:G7_9
I:[9] Andy Rooney
S:Computers may save time but they sure waste a lot of paper.  About 98 percent
 :of everything printed out by a computer is garbage that no one ever reads.

*:G7_10
I:[10] Reshma Saujani
S:Computer science is not just for smart 'nerds' in hoodies coding in basements.
 :Coding is extremely creative and is an integral part of almost every industry.

Q:Do you want to continue to next lesson [Y/N] ? 
N:MENU

# ###########################################################################

*:PHILOSOPHY
B:Philosophical Thoughts: Man, Mind, Machine, etc.

*:PHIL_1
I:[1] Augusta Ada King, Countess of Lovelace ("Ada Lovelace")
S:The Analytical Engine has no pretensions whatever to originate anything.  It can
 :do whatever we know how to order it to perform.  It can follow analysis; but it
 :has no power of anticipating any analytical relations or truths.  Its province to
 :assist us to making available what we are already acquainted with.

*:PHIL_2
I:[2] Alan Turing
S:The idea behind digital computers may be explained by saying that these machines
 :are intended to carry out any operations which could be done by a human computer.

*:PHIL_3
I:[3] Alan Turing
S:A man provided with paper, pencil, and rubber, and subject to strict discipline,
 :is in effect a universal machine.

*:PHIL_4
I:[4] Rudy Rucker
S:Computations are everywhere, once you begin to look at things in a certain way.

*:PHIL_5
I:[5] Seth Lloyd
S:I have not proved that the universe is, in fact, a digital computer and that
 :it's capable of performing universal computation, but it's plausible that it is.

*:PHIL_6
I:[6] John McCarthy, "Towards a Mathematical Science of Computation"
S:Let me re-assert that the question of whether there are limitations in
 :principle of what problems man can make machines solve for him as compared
 :to his own ability to solve problems, really is a technical question in
 :recursive function theory.

*:PHIL_7
I:[7] Augusta Ada King, Countess of Lovelace ("Ada Lovelace")
S:The Analytical Engine weaves algebraic patterns, just as the Jacquard loom weaves
 :flowers and leaves.

*:PHIL_8
I:[8] Augusta Ada King, Countess of Lovelace ("Ada Lovelace")
S:Many persons who are not conversant with mathematical studies imagine that because
 :the business of [Babbage's Analytical Engine] is to give its results in numerical
 :notation, the nature of its processes must consequently be arithmetical and
 :numerical, rather than algebraical and analytical.  This is an error.
 :
 :The engine can arrange and combine its numerical quantities exactly as if they
 :were letters or any other general symbols; and in fact it might bring out its
 :results in algebraic notation, were provisions made accordingly.

*:PHIL_9
I:[9] Gregory Bateson, "Mind and Nature"
S:Thirty years ago, we used to ask: Can a computer simulate all processes of logic?
 :The answer was "yes", but the question was surely wrong.  We should have asked:
 :Can logic simulate all sequences of cause and effect? And the answer would have
 :been "no".

*:PHIL_10
I:[10] Jordan Ellenberg, "How Not to Be Wrong: The Power of Mathmetical Thinking"
S:Dividing one number by another is mere computation; knowing what to divide by
 :what is mathematics.

*:PHIL_11
I:[11] Rudy Rucker
S:We're presently in the midst of third intellectual revolution.  The first came
 :with Newton: the planets obey physical laws.  The second came with Darwin: biology
 :obeys genetic laws.  In today's third revolution, we're coming to realize that
 :even minds and societies emerge from interacting laws that can be regarded as
 :computations.  Everything is computation.

*:PHIL_12
I:[12] Stephen Wolfram
S:It's always seemed like a big mystery how nature, seemingly so effortlessly,
 :manages to produce so much that seems to us so complex.  Well, I think we found
 :its secret.  It's just sampling what's out there in the computational universe.

*:PHIL_13
I:[13] Michael Sipser, "Introduction to The Theory of Computation"
S:Theory is relevant to you because it shows you a new, simpler, and more elegant
 :side of computers, which we normally consider to be complicated machines.
 :The best computer designs and applications are conceived with elegance in mind.
 :A theoretical course can heighten your aesthetic sense and help you build more
 :beautiful systems.

*:PHIL_14
I:[14] Abhijit Naskar, "Mission Reality"
S:Computation is not the same as thought and emulation is not the same as imagination.

*:PHIL_15
I:[15] Paul Graham
S:If you understand McCarthy's eval, you understand more than just a stage in the 
 :history of languages.  These ideas are still the semantic core of Lisp today.  
 :So studying McCarthy's original paper shows us, in a sense, what Lisp really is.  
 :It's not something that McCarthy designed so much as something he discovered.
 :It's not intrinsically a language for AI or for rapid prototyping, or any other
 :task at that level.  It's what you get (or one thing you get) when you try to
 :axiomatize computation.

*:PHIL_16
I:[16] Laura F. Landweber, "Evolution as Computation", Princeton 1999
S:It is now plausible at the molecular level to conceive of concerted, non-random
 :changes in the genome guided by cellular computing networks during episodes of
 :evolutionary change.  Thus, just as the genome has come to be seen as a highly
 :sophisticated information storage system, its evolution has become a matter of
 :highly sophisticated information processing.

*:PHIL_17
I:[17] Jaron Lanier, "Who Owns the Future?"
S:The reason Maxwell's Demon cannot exist is that it does take resources to perform
 :an act of discrimination.  We imagine computation is free, but it never is.  The 
 :very act of choosing which particle is cold or hot itself becomes an energy drain
 :and a source of waste heat.  The principle is also known as "no free lunch".
 :
 :We do our best to implement Maxwell's Demon whenever we manipulate reality with
 :our technologies, but we can never do so perfectly; we certainly can't get ahead
 :of the game, which is known as entropy.  All the air conditioners in a city emit
 :heat that makes the city hotter overall.  While you can implement what seems to be
 :a Maxwell's Demon if you don't look too far or too closely, in the big picture you
 :always lose more than you gain.
 :
 :Every bit in computer is a wannabe Maxwell's Demon, separting the state of "one"
 :from the state of "zero" for a while, at a cost.  A computer on a network can also
 :act like a wannabe demon if it tries to sort data from networked people into one
 :or the other side of some imaginary door, while pretending there is no cost or
 :risk involved.

*:PHIL_18
I:[18] Geoffrey Hinton
S:I have always been convinced that the only way to get artificial intelligence to 
 :work is to do computation in a way similar to the human brain.  That is the goal
 :I have been pursuing.  We are making progress, though we still have lots to learn
 :about how the brain actually works.

*:PHIL_19
I:[19] Howard Aiken
S:The desire to economize time and mental effort in arithmetical computations, and to
 :eliminate human liability to error is probably as old as the science of arithmetic
 :itself.

*:PHIL_20
I:[20] Rudy Rucker
S:A computation is a process that obeys finitely describable rules.

*:PHIL_21
I:[21] Stephen Hawking
S:There is no physical law precluding particles from being organised in ways that
 :perform even more advanced computations than the arrangements of particles in
 :human brain.

*:PHIL_22
I:[22] Roger Penrose
S:If you come from mathematics, as I do, you realize that there are many problems,
 :even classical problems, which cannot be solved by computation alone.

*:PHIL_23
I:[23] Martin Rees
S:Some things, like the orbits of the planets, can be calculated far into the future.
 :But that's atypical.  In most contexts, there is a limit.  Even the most fine-
 :grained computation can only forecast British weather a few days ahead.  There are
 :limits to what can ever be learned about the future, however powerful computers
 :become.

*:PHIL_24
I:[24] Orison Swett Marden
S:The achievements of willpower are almost beyond computation.  Scarcely anything 
 :seems impossible to the man who can will strongly enough and long enough.

*:PHIL_25
I:[25] Seth Lloyd
S:One of the things that I've been doing recently in my scientific research is to ask
 :this question: Is the universe actually capable of performing things like digital
 :computations?

*:PHIL_26
I:[26] Seth Lloyd
S:All physical systems can be thought of as registering and processing information,
 :and how one wishes to define computation will determine your view of what 
 :computation consists of.

*:PHIL_27
I:[27] Rudy Rucker
S:Lately I've been working to convince myself that everything is a computation.

*:PHIL_28
I:[28] Rudy Rucker
S:If you think of your life as a kind of computation, it's quite abundantly clear 
 :that there's not going to be a final answer and there won't be anything 
 :particularly wonderful about having the computation halt!

*:PHIL_29
I:[29] Rudy Rucker
S:If we suppose that many natural phenomena are in effect computations, the study of
 :computer science can tell us about the kinds of natural phenomena that can occur.

*:PHIL_30
I:[30] David Deutsch
S:To me quantum computation is a new and deeper and better way to understand the laws
 :of physics, and hence understanding physical reality as a whole.

*:PHIL_31
I:[31] Steven Pinker
S:I spent 20 years doing research on regular and irregular verbs, not because I'm an
 :obsessive language lover but because it seemed to me that they tapped into a
 :fundamental distinction in language processing, indeed in cognitive processing,
 :between memory lookup and rule-driven computation.

*:PHIL_32
I:[32] Edsger Dijkstra
S:Computer science is no more about computers than astronomy is about telescopes.

*:PHIL_33
I:[33] Isaac Newton
S:Truth is ever to be found in the simplicity, and not in the multiplicity and
 :confusion of things.

*:PHIL_34
I:[34] John A. Van de Walle
S:Mathematics is much more than computation with pencil and a paper and getting
 :answers to routine exercises.  In fact, it can easily be argued that computation,
 :such as doing long division, is not mathematics at all.  Calculators can do the
 :same thing and calculators can only calculate they cannot do mathematics.

*:PHIL_35
I:[35] L. Ron Hubbard
S:Imagination is actually a form of computation.  Imagination gives calculated and
 :instinctive solutions for the future.

*:PHIL_36
I:[36] Leonard Adleman
S:Biology and computer science - life and computation - are related.  I am confident
 :that at their interface great discoveries await those who seek them.

*:PHIL_37
I:[37] Seth Lloyd
S:We couldn't build quantum computers unless the universe were quantum and computing.
 :We can build such machines because the universe is storing and processing
 :information in the quantum realm.  When we build quantum computers, we're hijacking
 :that underlying computation in order to make it do things we want: little and/or/not
 :calculations.  We're hacking into the universe.

*:PHIL_38
I:[38] Howard Aiken
S:At the present time there exist problems beyond our ability to solve, not because
 :of theoretical difficulties, but because of insufficient means of mechanical 
 :computation.

*:PHIL_39
I:[39] Peter Hilton
S:Computation involves going from a question to an answer.
 :Mathematics involves going from an answer to a question.

*:PHIL_40
I:[40] Seth Lloyd
S:A classical computation is like a solo voice -- one line of pure tones succeeding
 :each other.  A quantum computation is like a symphony -- many lines of tones
 :interfering with one another.

Q:Do you want to continue to next lesson [Y/N] ? 
N:MENU

# ###########################################################################

*:PHILOSOPHY_2
B:Philosophical Thoughts: Man, Mind, Machine, etc. #2

*:PHIL2_1
I:[1] Charles Babbage
S:On two occasions I have been asked: "If you put into the machine wrong figures, 
 :will the right answers come out?"
 :
 :I am not able rightly to apprehend the kind of confusion of ideas that could 
 :provoke such a question.

*:PHIL2_2
I:[2] Stephen Hawking
S:I think computer viruses should count as life.  I think it says something about
 :human nature that the only form of life we have created is purely destructive.
 :We've created life in our own image.

*:PHIL2_3
I:[3] Arthur C. Clarke, "2010: Odyssey Two"
S:Whether we are based on carbon or on silicon makes no fundamental difference;
 :we should each be treated with appropriate respect.

*:PHIL2_4
I:[4] Jaron Lanier, "You Are Not a Gadget"
S:Emphasizing the crowd means de-emphasizing individual humans in the design of
 :society, and when you ask people not to be people, they revert to bad, mob-like
 :behaviors.

*:PHIL2_5
I:[5] Steve Wozniak
S:"All of a sudden, we've lost a lot of controls," he said.  "We can't turn off
 :our internet; we can't turn off our smartphones; we can't turn off our computers.
 :You used to ask a smart person a question.  Now, who do you ask? It starts with
 :g-o, and it's not God..."

*:PHIL2_6
I:[6] Michael Crichton, "The Terminal Man"
S:... we have created a man with not one brain but two.  This new brain is intended
 :to control the biological brain.  The patient's biological brain is the peripheral
 :terminal -- the only peripheral terminal -- for the new computer.  And therefore
 :the patient's brain, indeed his whole body, has become a terminal for the new
 :computer.  We have created a man who is one single, large, complex computer
 :terminal.  The patient is a read-out device for the new computer, and is helpless
 :to control the readout as a TV screen is helpless to control the information
 :presented on it.

*:PHIL2_7
I:[7] Veronica Roth, "Divergent"
S:Two things you should know about me; The first is that I am deeply suspicious of
 :people in general.  It is my nature to expect the worst of them.  

*:PHIL2_8
I:[8] Richard Dawkins
S:Personally, I rather look forward to a computer program wining the world chess
 :championship.  Humanity needs a lesson in humility.

*:PHIL2_9
I:[9] Louis V. Gerstner, Jr.
S:Computers are magnificent tools for the realization of our dreams, but no machine
 :can replace the human spark of spirit, compassion, love, and understanding.

*:PHIL2_10
I:[10] Sydney J. Harris
S:The real danger is not that computers will begin to think like men, but that men
 :will begin to think like computers.

*:PHIL2_11
I:[11] Adam Osborne
S:The future lies in designing and selling computers that people don't realize
 :are computers at all.

*:PHIL2_12
I:[12] Alan Kay
S:Computer science inverts the normal.  In normal science, you're given a world,
 :and your job is to find out the rules.  In computer science, you give the 
 :computer the rules, and it creates the world.

*:PHIL2_13
I:[13] Paul Allen
S:The promise of artificial intelligence and computer science generally vastly
 :outweighs the impact it could have on some jobs in the same way that, while the
 :invention of the airplane negatively affected the railroad industry, it opened
 :a much wider door to human to progress.

*:PHIL2_14
I:[14] Isaac Asimov, "Robot Visions"
S:In a properly automated and educated world, then, machines may prove to be the
 :true humanizing influence.  It may be that machines will do the work that makes
 :life possible and that human beings will do all the other things that make life
 :pleasant and worthwhile.

*:PHIL2_15
I:[15] William S. Burroughs
S:The study of thinking machines teaches us more about the brain than we can learn
 :by introspective methods.  Western man is externalizing himself in the form of
 :gadgets.

*:PHIL2_16
I:[16] Alan Turing, "Mechanical Intelligence: Collected Works of A.M. Turing"
S:The original question, 'Can machines think?' I believe to be too meaningless
 :to deserve discussion.

*:PHIL2_17
I:[17] Douglas Rushkoff, "Program or Be Programmed: Ten Commands for a Digital Age"
S:We are looking at a society increasingly dependent on machines, yet decreasingly
 :capable of making or even using them effectively.

*:PHIL2_18
I:[18] Bill Watterson, "There's Treasure Everywhere"
S:We don't value craftsmanship anymore! All we value is ruthless efficiency, and
 :I say we deny our own humanity that way! Without appreciation for grace and
 :beauty, there's no pleasure in creating things and no pleasure in having them!
 :
 :Our lives are made drearier, rather than richer! How can a person take pride
 :in his work when skill and care are considered luxuries! We're not machines!
 :We have a human need for craftsmanship.

*:PHIL2_19
I:[19] Hugo Cabret (Fictional Character)
S:I'd imagine the whole world was one big machine.  Machines never come with any
 :extra parts, you know.  They always come with the exact amount they need.  So I
 :figured, if the entire world was one big machine, I couldn't be an extra part.
 :I had to be here for some reason.  And that means you have to be here for some
 :reason, too.

*:PHIL2_20
I:[20] Adrian Tchaikovsky, "Blood of the Mantis"
S:Progress is made by the improvement of people, not the improvement of machines.

*:PHIL2_21
I:[21] Louise Gluck, "The Wild Iris"
S:Go ahead: say what you're thinking. 
 :The garden is not the real world.
 :Machines are the real world.

*:PHIL2_22
I:[22] Kurt Vonnegut, "Breakfast of Champions"
S:So, in the interests of survival, they trained themselves to be agreeing machines
 :instead of thinking machines.  All their minds had to do was to discover what
 :other people were thinking, and then they thought that, too.

*:PHIL2_23
I:[23] Kai-Fu Lee
S:Part of why predicting the ending to our artificial intelligence story is so
 :difficult is because this isn't just a story about machines.  It's also a story
 :about human beings, people with free wills that allows them to make their own
 :choices and to shape their own destinies.  Our AI future will be created by us,
 :and it will reflect the choices we make and the actions we take.

*:PHIL2_24
I:[24] E.M. Forster, "The Machine Stops"
S:Cannot you see, cannot you all lecturers see, that it is we that are dying and
 :that down here the only thing that really lives is the Machine?
 :
 :We created the Machine, to do our will, but we cannot make it do our will now.
 :It has robbed us of the sense of space and of the sense of touch, it has blurred
 :every human relation and narrowed down love to a carnal act, it has paralysed
 :our bodies and our wills, and now it compels us to worship it.  The Machine
 :develops -- but not on our lines.  The Machine proceeds -- but not to our goal.
 :We only exist as the blood corpuscles that course through its arteries, and if
 :it could work without us, it would let us die.

*:PHIL2_25
I:[25] Steve Toutonghi, "Side Life"
S:The machines of the mind are more difficult to recognize than machines of
 :iron and steam.

*:PHIL2_26
I:[26] Dahi Tamara Koch, "Within the event horizon: Poetry prose"
S:Emotions make us human.  Without being able to feel something, we cannot be
 :anything more than machines.

*:PHIL2_27
I:[27] Richie Norton
S:The industrial model is gone.  People are more than machines.

*:PHIL2_28
I:[28] Gary William Flake, "The Computational Beauty of Nature"
S:The goal of this book is to highlight the computational beauty found in
 :nature's program.

*:PHIL2_29
I:[29] Gary William Flake, "The Computational Beauty of Nature"
S:Reductionism is a powerful way of looking at the universe.  But this begs a
 :somewhat silly question: Since everything ultimately breaks down to the quantum
 :level, why aren't all scientists mathematicians at the core? In such a world
 :physicians would make diagnoses based on the patient's bodily quarks, which
 :makes about as much sense as building a house particle by particle.  Neverthe-
 :less, every scientist must possess some knowledge of the level one step more
 :fundamental than his or her specialty, but at some point reductionism must stop
 :for science to be effective.

*:PHIL2_30
I:[30] Gary William Flake, "The Computational Beauty of Nature"
S:Now, suppose that we wished to describe how the universe works.  We could take
 :a reductionist's approach and catalog all the different types of objects that
 :exist -- perhaps starting with galaxy clusters, hitting terrestrial life forms
 :about midway through, and then ending with subatomic particles -- but would this
 :approach rally succeed in describing the universe?
 :
 :In making a large list of "things" it is easy to forget that the manner in which
 :"things" work more often than not depends on the environment in which they exist.
 :For example, we could describe the form of a duck in excruciating detail, but
 :this gives us only half of the story.  To really appreciate what a duck is, we
 :should look at ducks in the air, in water, in the context of what they eat and
 :what eats them, how they court, mate, and reproduce, the social structures they
 :form, how they flock, and their need to migrate.

*:PHIL2_31
I:[31] Gary William Flake, "The Computational Beauty of Nature"
S:Looking back at the organization of sciences, we find that at each level of
 :understanding, traditional scientists study two types of phenomena: agents
 :(molecules, cells, ducks, and species) and interactions of agents (chemical
 :reactions, immune system responses, duck mating, and evolution).
 :
 :Studying agents in isolation is a fruitful way of discovering insights into
 :the form and function of an agent, but doing so has some known limitations.
 :Specifically, reductionism fails when we try to use it in a reverse direction.
 :As we shall see throughout this book, having a complete and perfect under-
 :standing of how an agent behaves in no way guarantees that you will be able
 :to predict how this single agent will behave for all time or in the context
 :of other agents.

*:PHIL2_32
I:[32] Gary William Flake, "The Computational Beauty of Nature"
S:We have, then, three different ways of looking at how things work.  We can
 :take a purely reductionist approach and attempt to understand things through
 :dissection.  We also can take a wider view and attempt to understand whole
 :collections at once by observing how many agents, say the neurons in a brain,
 :form a global pattern, such as human intelligence.  Or we can take an inter-
 :mediate view and focus attention on the interactions of agents.  Through
 :this middle path, the interactions of agents can be seen to form the glue that
 :binds one level of understanding to the next level.

*:PHIL2_33
I:[33] Gary William Flake, "The Computational Beauty of Nature"
S:Any discrete piece of information can be represented by a set of numbers.
 :Systems that compute can represent powerful mappings from one set of numbers
 :to another.  Moreover, any program on any computer is equivalent to a number
 :mapping.  These mappings can be thought of as statements about the properties
 :of numbers; hence, there is a close connection between computer programs and
 :mathematical proofs.

*:PHIL2_34
I:[34] Gary William Flake, "The Computational Beauty of Nature"
S:[Cont] But there are more possible mappings than possible programs; thus, there
 :are some things that simply cannot be computed.  The actual process of computing
 :can be defined in terms of a very small number of primitive operations, with
 :recursion and/or iteration comprising the most fundamental pieces of a computing
 :device.  Computing devices can also make statements about other computing devices.
 :This leads to a fundamental paradox that ultimately exposes the limitations not
 :just of machine logic, but all of nature as well.

*:PHIL2_35
I:[35] Gary William Flake, "The Computational Beauty of Nature"
S:Later Turing proved that Turing machines could compute exactly the same functions
 :as lambda calculus, which proved that all three models of computation are equi-
 :valent.  This is a truly remarkable result, considering how different the three
 :models of computation are.  In Church's 1941 paper he made a statement that is
 :now known as the Church-Turing thesis:
 :
 :Any function that can be called computable can be comuted by lambda calculus,
 :a Turing machine, or a general recursive function.

*:PHIL2_36
I:[36] Gary William Flake, "The Computational Beauty of Nature"
S:[Cont] Recall the point that was made about functions describing relationships
 :between numbers and models of computation describing functions.  Well, the
 :Church-Turing thesis is yet another level more fundamental than a model of
 :computation.  As a statement about models of computation, it is not subject to
 :proof in the usual sense; thus, it is impossible to prove that the thesis is
 :correct.
 :
 :One could disprove it by coming up with a model of computation over discrete
 :elements that could calculate things that one of the other models could not;
 :however, this has not happened.  The fact that every posed model of computation
 :has always been exactly equivalent to (or weaker than) one of the others lend
 :strong support to the Church-Turing thesis.

Q:Do you want to continue to next lesson [Y/N] ? 
N:MENU

# ###########################################################################

*:MACHINE_INT
B:Machine, Artificial, and Intelligence in General

*:MI_1
I:Alan Turing, 1950
S:A computer would deserve to be called intelligent
 :if it could deceive a human into believing that it was human.

*:MI_2
I:Alan Turing, 1947
S:I believe that at the end of the century the use of words and general
 :educated opinion will have altered so much that one will be able to
 :speak of machines thinking without expecting to be contradicted.

*:MI_3
I:Alan Turing, 1951
S:It seems probable that once the machine thinking method had started,
 :it would not take long to outstrip our feeble powers.
 :
 :They would be able to converse with each other to sharpen their wits.
 :At some stage therefore, we should have to expect the machines to take control.

Q:Do you want to continue to next lesson [Y/N] ? 
N:MENU

# ###########################################################################

*:SW_ENG
B:Some thoughts on Software Development and Engineering

*:SW_1
I:[1] Grady Booch
S:The function of good software is to make the complex appear to be simple.

*:SW_2
I:[2] Steve McConnell
S:Good code is its own best documentation.

*:SW_3
I:[3] Eagleson's Law
S:Any code of your own that you haven't looked at for six or more months
 :might as well have been written by someone else.

*:SW_4
I:[4] Tom Cargill
S:The first 90% of code accounts for the first 90% of the development time.
 :The remaining 10% of code accounts for the other 90% of the development time.

*:SW_5
I:[5] Francis Glassborow
S:Good programmers use their brains, but good guidelines save us having
 :to think out every case.

*:SW_6
I:[6] Jeff Atwood
S:In software, we rarely have meaningful requirements.  Even if we do,
 :the only measure of success that matters is whether our solution solves
 :the customer's shifting idea of what their problem is.

*:SW_7
I:[7] Bill Clinton
S:Considering the current sad state of our computer programs, software
 :development is clearly still a black art, and cannot yet be called
 :an engineering discipline.

*:SW_8
I:[8] Jim McCarthy
S:You can't have great software without a great team, and most software
 :teams behave like dysfunctional families.

*:SW_9
I:[9] Brian Kernighan
S:Debugging is twice as hard as writing the code in the first place.
 :Therefore, if you write the code as cleverly as possible, you are
 :-- by definition -- not smart enough to debug it.

*:SW_10
I:[10] Vidiu Platon
S:I don't care if it works on your machine! We are not shipping your machine!

*:SW_11
I:[11] Michael Sinz
S:Programming is like sex: "One" mistake and you're providing support
 :for a lifetime.

*:SW_12
I:[12] Alan J. Perlis
S:There are two ways to write error-free programs; only the third one works.

*:SW_13
I:[13] Bertrand Meyer
S:You can either have software quality or you can have pointer arithmetic,
 :but you cannot have both at the same time.

*:SW_14
I:[14] Ray Ozzie
S:Complexity kills.  It sucks the life out of developers, it makes products
 :difficult to plan, build, and test, it introduces security challenges,
 :and it causes end-user and administrator frustration.

*:SW_15
I:[15] C.A.R Hoare
S:There are two ways of constructing a software design.
 :One way is to make it so simple that there are obviously no deficiencies.
 :And the other way is to make it so complicated that there are no
 :obvious deficiencies.

*:SW_16
I:[16] Mark Minasi
S:If McDonalds were run like a software company, one out of every hundred
 :Big Macs would give you food poisoning, and the response would be,
 :'We're sorry, here's a coupon for two more.'.

*:SW_17
I:[17] Paul Ehrlich
S:To err is human, but to really foul things up you need a computer.

*:SW_18
I:[18] Mitch Radcliffe
S:A computer lets you make more mistakes faster than any invention in
 :human history - with the possible exceptions of handguns and tequila.

*:SW_19
I:[19] Bjarne Stroustrup
S:There's an old story about the person who wished his computer were as easy
 :to use as his telephone.  That wish has come true, since I no longer know
 :how to use my telephone.

*:SW_20
I:[20] Douglas Crockford, "JavaScript: The Good Parts"
S:We see a lot of feature-driven product design in which the cost of features
 :is not properly accounted.  Features can have a negative value to customers
 :because they make the products more difficult to understand and use.
 :
 :We are finding that people like products that just works.  It turns out that
 :designs that just work are much harder to produce than designs that assemble
 :long list of features.

*:SW_21
I:[21] James Alan Gardner
S:What kind of programmer is so divorced from reality that she thinks she'll
 :get complex software right the first time?

*:SW_22
I:[22] Andrew Hunt, "The Pragmatic Programmer"
S:Don't gloss over a routine or piece of code involved in the bug because
 :you "know" it works.  Prove it.  Prove it in this context, with this data,
 :with these boundary conditions.

*:SW_23
I:[23] Robert C. Martin
S:Any organization that designs a system will produce a design whose structure
 :is a copy of the organization's communication structure.

*:SW_24
I:[24] Daniel Roy Greenfeld, Audrey Roy Greenfeld
S:Code is read more than it is written.

*:SW_25
I:[25] Ralph Johnson
S:Before software can be reusable it first has to be usable.

*:SW_26
I:[26] Frederick P. Brooks Jr.
S:What one programmer can do in one month, two programmers can do in two months.

*:SW_27
I:[27] Steve McConnell
S:It's okay to figure out murder mysteries, but you shouldn't need to figure out
 :code.  You should be able to read it.

*:SW_28
I:[28] Frederick P. Brooks Jr.
S:Plan to throw one [implementation] away; you will, anyhow.

*:SW_29
I:[29] Frederick P. Brooks Jr.
S:Adding manpower to a late software project makes it later!

*:SW_30
I:[30] Jim Highsmith
S:The best way to get a project done faster is to start sooner.

*:SW_31
I:[31] Douglas Hofstadter
S:Hofstadter's Law: It always takes longer than you expect, even when you take
 :into account Hofstadter's Law.

*:SW_32
I:[32] Bertrand Meyer
S:Incorrect documentation is often worse than no documentation.

*:SW_33
I:[33] Larry McVoy
S:Architect: Someone who knows the difference between that which could be done
 :and that which should be done.

*:SW_34
I:[34] J.D. Horton
S:Nothing resolves design issues like an implementation.

*:SW_35
I:[35] Putt's Law
S:Putt's Law: Technology is dominated by two types of people:
 :Those who understand what they do not manage.
 :Those who manage what they do not understand.

*:SW_36
I:[36] Steven Levy
S:There has never been an unexpectedly short debugging period in the history
 :of computers.

*:SW_37
I:[37] Terry Baker
S:A program is never less than 90% complete and never more than 95%.

Q:Do you want to continue to next lesson [Y/N] ? 
N:MENU

# ###########################################################################

*:SW_ENG_2
B:Some thoughts on Software Development and Engineering #2

*:SW2_1
I:[1] Steve Maguire
S:Fix the cause, not the symptom.

*:SW2_2
I:[2] Austin Freeman
S:Simplicity is the soul of efficiency.

*:SW2_3
I:[3] Kent Beck
S:Make it work, make it right, make it fast.

*:SW2_4
I:[4] Louis Srygley
S:Without requirements or design,
 :programming is the art of adding bugs
 :to an empty text file.

*:SW2_5
I:[5] Tom Van Vleck
S:We know about as much about software quality problems as they knew about
 :the Black Plague in the 1600s.  We've seen the victims' agonies and helped
 :burn the corpses.  We don't know what causes it; we don't really know if
 :there is only one disease.  We just suffer -- and keep pouring our sewage
 :into our water supply.

*:SW2_6
I:[6] Eric Raymond, "The Art of Unix Programming"
S:The combination of threads, remote-procedure-call interfaces, and heavyweight
 :object-oriented design is especially dangerous... if you are ever invited
 :onto a project that is supposed to feature all three, fleeing in terror might
 :well be an appropriate reaction.

*:SW2_7
I:[7] Anonymous
S:It is easier to change the specification to fit the program than vice versa.

*:SW2_8
I:[8] Donald E. Knuth
S:Beware of bugs in the above code; I have only proved it correct, not tried it.

*:SW2_9
I:[9] Nathaniel Borenstein
S:It should be noted that no ethically-trained software engineer would ever
 :consent to write a DestroyBaghdad procedure.  Basic professional ethics would
 :instead require him to write a DestroyCity procedure, to which Baghdad could
 :be given as a parameter.

*:SW2_10
I:[10] Andrew Tannenbaum
S:The nice thing about standards is that there are so many of them to choose from.

*:SW2_11
I:[11] Henry Baker
S:Software people would never drive to the office if building engineers and
 :automotive engineers were as cavalier about buildings and autos as the
 :software "engineer" is about his software.

*:SW2_12
I:[12] Norman Augustine
S:Software is like entropy: It is difficult to grasp, weighs nothing, and obeys
 :the Second Law of Thermodynamics; i.e., it always increases.

*:SW2_13
I:[13] Bill Curtis
S:In a room full of top software designers, if two agree on the same thing,
 :that's a majority.

*:SW2_14
I:[14] Antoine de Saint-Exupry
S:Perfection [in design] is achieved, not when there is nothing more to add,
 :but when there is nothing left to take away.

*:SW2_15
I:[15] Yoggi Berra
S:In theory, theory and practice are the same.  In practice, they're not.

*:SW2_16
I:[16] Alan Kay
S:Most software today is very much like an Egyptian pyramid with millions of
 :bricks piled on top of each other, with no structural integrity, but just
 :done by brute force and thousands of slaves.

*:SW2_17
I:[17] D. Adams
S:A common mistake people make when trying to design something completely
 :foolproof is to underestimate the ingenuity of complete fools.

*:SW2_18
I:[18] Richard P. Gabriel & Ron Goldman, "Mob Software: The Erotic Life of Code"
S:Software development methodologies evolved under this regime [figure it out,
 :code it up, compile it, run it, throw it away] along with mythical belief in
 :master planning.  Such beliefs were rooted in an elementary-school-level
 :fiction that great masterpieces were planned, or arose as a by-product of
 :physicists shovelling menial and rote coding tasks to their inferiors in the
 :computing department.  Master planning feeds off the desire for order,
 :a desire born of our fear of failure, our fear of death.

*:SW2_19
I:[19] Kent Beck, "Smalltalk Best Practice Patterns"
S:To me, development consists of two processes that feed each other.  First,
 :you figure out what you want the computer to do.  Then, you instruct the
 :computer to do it.  Trying to write those instructions inevitably changes
 :what you want the computer to do and so it goes.
 :
 :In this model, coding isn't the poor handmaiden of design or analysis.
 :Coding is where your fuzzy, comfortable ideas awaken in the harsh domain of
 :reality.  It is where you learn what your computer can do.  If you stop
 :coding, you stop learning.
 :
 :We aren't always good at guessing where responsibilities should go.  Coding
 :is where our design guesses are tested.  Being prepared to be flexible about
 :making design changes during coding results in programs that get better and
 :better over time.  Insisting that early ideas be carried through is short
 :sighted.

*:SW2_20
I:[20] Paul Graham, "ANSI Common Lisp"
S:Planning is necessary evil.  It is a response to risk: the more dangerous an
 :undertaking, the more important it is to plan ahead.  Powerful tools decrease
 :risk, and so decrease the need for planning.  The design of your program can
 :then benefit from what is probably the most useful source of information
 :available: the experience of implementing it.

*:SW2_21
I:[21] Boris Beizer, "Software Testing Techniques" 2E. 1990.
S:Software quality has almost nothing to do with algorithmic elegance, compact-
 :ness, or speed - in fact, those attributes do more harm to quality than good.
 :
 :The objective is to make things as clear as possible to the designer and to
 :yourself, and exessive formality can destroy clarity just as easily as modest
 :formality can enhance it.

*:SW2_22
I:[22] Boris Beizer, "Software Testing Techniques" 2E. 1990.
S:[The spec] Be literal in your interpretation and smile when the designer
 :accuses you of semantic nit-picking.
 :
 :In programming, it's often bugs in the specification that kill you.

*:SW2_23
I:[23] Boris Beizer, "Software Testing Techniques" 2E. 1990.
S:Let's face it: superb code and unit testing will be useless if the overall
 :design is poor.  And how can there be a rational, effective design if no one
 :on the design team can walk you through the more important transactions, step
 :by step and alternative by alternative.

*:SW2_24
I:[24] Frederick P. Brooks, Jr., "No Silver Bullet - Essence and Acccident in SW Eng"
S:The complexity of software is an essential property, not an accidental one.
 :Hence descriptions of a software entity that abstract away its complexity often
 :abstract aways its essence.

*:SW2_25
I:[25] Paul Graham
S:Great software, likewise, requires a fanatical devotion to beauty.  If you look
 :inside good software, you find that parts that no one is ever supposed to see
 :are beautiful too.  When it comes to code I behave in a way that would make me
 :eligible for prescripting drugs if I approached everyday life the same way.
 :It drives me crazy to see code that's badly indented, or that uses ugly
 :variable names.

*:SW2_26
I:[26] R. Pattis
S:The structure of a software system provides the ecology in which code is born,
 :matures, and dies.  A well-designed habitat allows for the successful evolution
 :of all components needed in a software system.

*:SW2_27
I:[27] D. Vargas
S:It's easy to cry "bug" when the truth is that you've got a complex system and
 :sometimes it takes a while to get all the components to co-exist peacefully.

*:SW2_28
I:[28] Frederick P. Brooks Jr.
S:Einstein argued that there must be simplified explanations of nature, because
 :God is not capricious or arbitrary.  No such faith comforts the software
 :engineer.

*:SW2_29
I:[29] Frederick P. Brooks Jr.
S:[Regarding the addition of more programmers to get a project completed faster]
 :Nine people can't make a baby in a month.

*:SW2_30
I:[30] Ken Thompson
S:One of my most productive days was throwing away 1,000 lines of code.

*:SW2_31
I:[31] Gerald Weinberg
S:If builders built buildings the way programmers wrote programs, then the first
 :woodpecker that came along would destroy civilization.

*:SW2_32
I:[32] Andy Hunt
S:No one in the brief history of computing has ever written a piece of perfect
 :software.  It's unlikely that you'll be the first.

*:SW2_33
I:[33] Andy Hunt and Dave Thomas
S:Don't repeat yourself.  Every piece of knowledge must have a single, unambiguous,
 :authoritative representation within a system.

*:SW2_34
I:[34] Phil Karlton
S:There are only two hard things in computer science: cache invalidation and
 :naming things.

*:SW2_35
I:[35] Leon Bambrick
S:There are two hard things in computer science: cache invalidation, naming things,
 :and off-by-one errors.

Q:Do you want to continue to next lesson [Y/N] ? 
N:MENU

# ###########################################################################

*:SW_ENG_3
B:Some thoughts on Software Development and Engineering #3

*:SW3_1
I:[1] Barry Boehm
S:Poor management can increase software costs more rapidly than any other factor.

*:SW3_2
I:[2] Anna Nachesa
S:If the programmers like each other, they play a game called 'pair programming'.
 :And if not then the game is called 'peer review'.

*:SW3_3
I:[3] Steve McConnell
S:It's better to wait for a productive programmer to become available than it is
 :to wait for the first available programmer to become productive.

*:SW3_4
I:[4] Anonymous
S:You start coding.  I'll go find out what they want.

*:SW3_5
I:[5] Scoff Cherf
S:To go faster, slow down.  Everybody who knows about orbital mechanics
 :understands that.

*:SW3_6
I:[6] Albert Einstein
S:The significant problems we face cannot be solved by
 :the same level of thinking that created them.

*:SW3_7
I:[7] Tom Van Vleck
S:When somebody begins a sentence with "IT WOULD BE NICE IF.."
 :the right thing to do is to wait politely for the speaker to finish.
 :No project ever gets around to the it-would-be-nice-features:
 :or if they do, they regret it.  Wait for sentences that begin
 :"WE HAVE TO.." and pay close attention, and see if you agree.

*:SW3_8
I:[8] Anonymous
S:Why do we never have time to do it right, but always have time to DO IT OVER?

*:SW3_9
I:[9] Bill Langley
S:The perfect project is POSSIBLE if one first documents a list of
 :ALL the UNKNOWNS.

*:SW3_10
I:[10] Sam Redwine, "Proceedings of the 4th International Software Process Workshop"
S:Software and cathedrals are much the same:
 :first we build them, then we pray.

*:SW3_11
I:[11] Frederick P. Brooks Jr.
S:The bearing of a child takes nine months, no matter how many women are assigned.

*:SW3_12
I:[12] Robert C. Martin
S:Indeed, the ratio of time spent reading versus writing is well over 10 to 1.
 :We are constantly reading old code as part of the effort to write new code.
 :Therefore, making it easy to read makes it easier to write.

*:SW3_13
I:[13] Frederick P. Brooks Jr.
S:The conclusion is simple: if a 200-man project has 25 managers who are the
 :most competent and experienced programmers, fire the 175 troops and put the
 :managers back to programming.

*:SW3_14
I:[14] Yegor Bugayenko, "Code Ahead: Vol. 1"
S:Any software project must have a technical leader, who is responsible for all
 :technical decisions made by the team and have enough authority to make them.
 :Responsibility and authority are two mandatory components that must be present
 :in order to make it possible to call such a person an architect.

*:SW3_15
I:[15] Scott Rosenberg, "Dreaming in Code"
S:Software is easy to make, except when you want it to do something new.
 :And then, of course, there is a corollary: The only software that's worth
 :making is software that does something new.

*:SW3_16
I:[16] Edmond Lau, "The Effective Engineer"
S:In his book, Software Abstractions, MIT Professor Daniel Jackson explains just
 :how important it is to choose the right abstractions.  "Pick the right ones,
 :and programming will flow naturally from design; modules will have small and
 :simple interfaces; and new functionality will more likely fit in without
 :extensive reorganization," Jackson writes.  "Pick the wrong ones, and program-
 :ming will be a series of nasty surprises: interfaces will become baroque and
 :clumsy as they are forced to accommodate unanticipated interactions, and even
 :the simplest changes will be hard to make.

*:SW3_17
I:[17] Piethein Strengholt
S:Connascence, in the context of software engineering, refers to the degree of
 :coupling between software components.  Software components are connascent if
 :a change in one would require the other(s) to be modified in order to maintain
 :the overall correctness of the system.

*:SW3_18
I:[18] Laurent Bossavit, "The Leprechauns of Software Engineering"
S:A lot of research in software engineering strikes me as hopelessly naive in
 :one or two ways.  Most of it fails entirely to account for the social and
 :belief aspects altogether.  It looks at its object of inquiry as if it was
 :entirely material and inert; as if "software" was some kind of naturally
 :occurring substance, the properties of which can be revealed in the equivalent
 :of a test tube.

*:SW3_19
I:[19] Dominica Degrandis, "Making Work Visible"
S:Businesses frequently prioritize new feature releases over fixing technical
 :debt.  They choose to work on revenue-generating work instead of revenue-
 :protection work.  This rarely works out as the business hopes, particularly
 :as problems discovered during the final stages of uncompleted projects drag
 :engineers away from the newer projects.

*:SW3_20
I:[20] Niklaus Wirth
S:The belief that complex systems require armies of designers and programmers is
 :wrong.  A system that is not understood in its entirety, or at least to a
 :significant degree of detail by a single individual, should probably not
 :be built.

*:SW3_21
I:[21] Niklaus Wirth
S:A primary cause of complexity is that software vendors uncritically adopt
 :almost any feature that users want.

*:SW3_22
I:[22] Frederick P. Brooks Jr.
S:Good judgement comes from experience, and experience comes from bad judgement.

*:SW3_23
I:[23] Dennis Ritchie
S:... with proper design, the features come cheaply.  This approach is arduous,
 :but continues to succeed.

*:SW3_24
I:[24] Bertrand Meyer
S:Correctness is clearly the prime quality.  If a system does not do what it is
 :suppose to do, then everything else about it matters little.

*:SW3_25
I:[25] Frederick P. Brook Jr.
S:Conceptual integrity is the most important consideration in system design.

*:SW3_26
I:[26] Eric Raymond
S:Ugly programs are like ugly suspension bridges: they're much more liable to
 :collapse than pretty ones, because the way humans (especially engineer-human)
 :perceive beauty is intimately related to our ability to process and understand
 :complexity.

*:SW3_27
I:[27] Andy Hunt and David Thomas
S:It's not at all important to get it right the first time.  It's vitally
 :important to get it right the last time.

*:SW3_28
I:[28] Taligent's Guide to Designing Programs
S:Remember that there is no code faster than no code.

*:SW3_29
I:[29] John Carmack
S:... the cost of adding a feature isn't just the time it takes to code it.
 :The cost also includes the addition of an obstacle to future expansion.
 :The trick is to pick the features that don't fight each other.

*:SW3_30
I:[30] Frederick P. Brooks Jr.
S:The fundamental problem with program maintenance is that fixing a defect has
 :a substantial (20-50 percent) chance of introducing another.  So the whole
 :process is two steps forward and one step backward.

*:SW3_31
I:[31] Kevlin Henney, "The Imperial Clothing Crisis" (2002)
S:Refactoring provides enough energy to a system for it to relax into a new
 :and more comfortable state, a new local minimum.

*:SW3_32
I:[32] Kent Beck
S:Good engineering is not primarily making good decisions, it's seeking good
 :feedback which lets you quickly discard bad decisions.

*:SW3_33
I:[33] Bjarne Stroustrup
S:The most important single aspect of software development is to be clear
 :about what you are trying to build.

*:SW3_34
I:[34] David Parnas
S:Q: What is the most often-overlooked risk in software engineering?
 :
 :A: Incompetent programmers.  There are estimates that the number of programmers
 :needed in the U.S. exceeds 200,000.  This is entirely misleading.  It is not a
 :quantity problem; we have a quality problem.  One bad programmer can easily
 :create two new jobs a year.  Hiring more bad programmers will just increase
 :our perceived need for them.  If we had more good programmers, and could easily
 :identify them, we would need fewer, not more.

Q:Do you want to continue to next lesson [Y/N] ? 
N:MENU

# ###########################################################################

*:SW_ENG_4
B:Some thoughts on Software Development and Engineering #4

*:SW4_1
I:[1] Steve Swartz
S:When you are stuck in a traffic jam with a Porsche, all you do is burn more gas
 :in idle.  Scalability is about building wider roads, not about building faster cars.

*:SW4_2
I:[2] Paul Graham
S:Everyone by now presumably knows about the danger of premature optimization.
 :I think we should be just as worried about premature design -- designing too early
 :what a program should do.

*:SW4_3
I:[3] Danny Thorpe
S:Programming without an overall architecture or design in mind is like exploring
 :a cave with only a flashlight: You don't know where you've been, you don't know
 :where you're going, and you don't know quite where you are.

*:SW4_4
I:[4] David Hubel
S:We need above all to know about changes; no one wants or needs to be reminded
 :16 hours a day that his shoes are on.

*:SW4_5
I:[5] IO Angell
S:Today, most software exists, not to solve a problem,
 :but to interface with other software.

*:SW4_6
I:[6] David Parnas
S:As a rule, software systems do not work well until they have been used, and have
 :failed repeatedly, in real applications.

*:SW4_7
I:[7] Gordon Schulmeyer
S:In a software project team of 10, there are probably 3 people who produce enough
 :defects to make them net negative producers.

*:SW4_8
I:[8] Edsger Dijkstra
S:Program testing can be a very effective way to show the presence of bugs, but is
 :hopelessly inadequate for showing their absence.

Q:Do you want to continue to next lesson [Y/N] ? 
N:MENU

# ###########################################################################

*:OPTMZ_1
B:Concerning Performance, Speed, and Optimization  

*:OTM_1
I:[1] Donald E. Knuth
S:Programmers waste enormous amounts of time thinking about, or worrying about,
 :the speed of noncritical parts of their programs, and these attempts at
 :efficiency actually have a strong negative impact when debugging and
 :maintenance are considered.  We should forget about small efficiencies, say
 :about 97% of the time: premature optimization is the root of all evil.  Yet
 :we should not pass up our opportunities in that critical 3%.

*:OTM_2
I:[2] W. Wulf
S:More bugs have introduced into programs through premature optimization than
 :any other cause, including pure stupidity.
 :
 :(Sometimes quoted as:)
 :More computing sins are committed in the name of efficiency, without 
 :necessarily achieving it, than for any other single reason - including blind
 :stupidity.

*:OTM_3
I:[3] Donald E. Knuth
S:You're bound to be unhappy if you optimize everything.

*:OTM_4
I:[4] Steve McConnell
S:The big optimizations come from refining the high-level design, not the
 :individual routines.

*:OTM_5
I:[5] Christer Ericson
S:Premature optimization, that's like a sneeze.
 :Premature abstraction is like ebola; it makes my eyes bleed.

*:OTM_6
I:[6] Elements of Programming Style, Kernighan & Plauger
S:Let your compiler do the simple optimizations.

*:OTM_7
I:[7] The Art of Unix Programming, Eric Raymond
S:Rule of Optimization:
 :Prototype before polishing.  Get it working before you optimize it.

*:OTM_8
I:[8] The Art of Unix Programming, Eric Raymond
S:Rushing to optimize before the bottlenecks are known may be the only error to
 :have ruined more designs than feature creep.  From tortured code to incomprehen-
 :sible data layouts, the results of obsessing about speed or memory or disk usage
 :at the expense of transparency and simplicity are everywhere.  They spawn
 :innumerable bugs and cost millions of man-hours—often, just to get marginal
 :gains in the use of some resource much less expensive than debugging time.
 :Disturbingly often, premature local optimization actually hinders global
 :optimization (and hence reduces overall performance).  A prematurely optimized
 :portion of a design frequently interferes with changes that would have much
 :higher payoffs across the whole design, so you end up with both inferior
 :performance and excessively complex code.

*:OTM_9
I:[9] Peter Gabriel
S:The very architecture of almost every computer today is designed to optimize
 :the performance of Fortran programs and its operating-system-level sister, C.

*:OTM_10
I:[10] D. Jones
S:The fastest algorithm can frequently be replaced by one that is almost as fast
 :and much easier to understand.

*:OTM_11
I:[11] Kent Beck
S:Make it work, make it right, make it fast.

*:OTM_12
I:[12] Elements of Programming Style, Kernighan & Plauger
S:Make it right before you make it faster.

*:OTM_13
I:[13] Elements of Programming Style, Kernighan & Plauger
S:Make it fail-safe before you make it faster.

*:OTM_14
I:[14] Elements of Programming Style, Kernighan & Plauger
S:Make it clear before you make it faster.

*:OTM_15
I:[15] Elements of Programming Style, Kernighan & Plauger
S:Keep it simple to make it faster.

*:OTM_16
I:[16] Elements of Programming Style, Kernighan & Plauger
S:Don't diddle code to make it faster -- find a better algorithm.

*:OTM_17
I:[17] Jon Bentley and Doug McIlroy
S:The key to performance is elegance, not battalions of
 :special cases.

*:OTM_18
I:[18] John Ousterhout
S:The best performance improvement is the transition from the nonworking state
 :to the working state.

*:OTM_19
I:[19] Elements of Programming Style, Kernighan & Plauger
S:Instrument your programs.  Measure before making efficiency changes.

*:OTM_20
I:[20] S. Heller, in "Efficient C/C++ Programming"
S:The speed of a non-working program is irrelevant.

*:OTM_21
I:[21] Boris Beizer, "Software Testing Techniques" 2E. 1990.
S:Software quality has almost nothing to do with algorithmic elegance, compact-
 :ness, or speed - in fact, those attributes do more harm to quality than good.

*:OTM_22
I:[22] Donald E. Knuth, "Selected Papers on Computer Science"
S:The best programs are written so that computing machines can perform
 :them quickly and so that human beings can understand them clearly.
 :A programmer is ideally an essayist who works with traditional aesthetic
 :and literary forms as well as mathematical concepts, to communicate
 :the way that an algorithm works and to convince a reader that the results
 :will be correct.

*:OTM_23
I:[23] D. Gelernter, "Machine Beauty"
S:Beauty is more important in computing than anywhere else in technology because
 :software is so complicated.  Beauty is the ultimate defense against complexity.
 :The geniuses of the computer field, on the other hand, are the people with
 :keenest aesthetic senses, the ones who are capable of creating beauty.  Beauty
 :is decisive at every level: the most important interfaces, the most important
 :programming languages, the winning algorithms are the beautiful ones.
 
*:OTM_24
I:[24] Alan J. Perlis
S:Optimization hinders evolution.  Everything should be built top-down, except the
 :first time.  Simplicity does not precede complexity, but follows it.

*:OTM_25
I:[25] William A. Dembski
S:Constrained optimization is the art of compromise between conflicting objectives.
 :This is what design is all about.  To find fault with biological design - as
 :Stephen Jay Gould regularly does - because it misses some idealized optimum is
 :therefore gratuitous.  Not knowing the objectives of the designer, Gould is in no
 :position to say whether the designer has proposed a faulty compromise among those
 :objectives.

*:OTM_26
I:[26] Larry Constantine
S:In fast moving markets, adaptation is significantly more important
 :than optimization.

*:OTM_27
I:[27] Rob Pike
S:Caches aren't architecture, they're just optimization.

*:OTM_28
I:[28] Erik Naggum
S:Optimization is generally detrimental to future success, but it is the only way
 :to accomplish present success in competition with others who are equally interested
 :in short-term results.

Q:Do you want to continue to next lesson [Y/N] ? 
N:MENU

# ###########################################################################

*:ELEM_PRG
B:From "The Elements of Programming Style" Book

*:ELEM_P_1
I:[1]
S:Write clearly -- don't be too clever.

*:ELEM_P_2
I:[2]
S:Say what you mean, simply and directly.

*:ELEM_P_3
I:[3]
S:Use library functions whenever feasible.

*:ELEM_P_4
I:[4]
S:Avoid too many temporary variables.

*:ELEM_P_5
I:[5]
S:Write clearly -- don't sacrifice clarity for efficiency.

*:ELEM_P_6
I:[6]
S:Let the machine do the dirty work.

*:ELEM_P_7
I:[7]
S:Replace repetitive expressions by calls to common functions.

*:ELEM_P_8
I:[8]
S:Parenthesize to avoid ambiguity.

*:ELEM_P_9
I:[9]
S:Choose variable names that won't be confused.

*:ELEM_P_10
I:[10]
S:Avoid unnecessary branches.

*:ELEM_P_11
I:[11]
S:If a logical expression is hard to understand, try transforming it.

*:ELEM_P_12
I:[12]
S:Choose a data representation that makes the program simple.

*:ELEM_P_13
I:[13]
S:Write first in easy-to-understand pseudo language; then translate into
 :whatever language you have to use.

*:ELEM_P_14
I:[14]
S:Modularize.  Use procedures and functions.

*:ELEM_P_15
I:[15]
S:Avoid gotos completely if you can keep the program readable.

*:ELEM_P_16
I:[16]
S:Don't patch bad code -- rewrite it.

*:ELEM_P_17
I:[17]
S:Write and test a big program in small pieces.

*:ELEM_P_18
I:[18]
S:Use recursive procedures for recursively-defined data structures.

*:ELEM_P_19
I:[19]
S:Test input for plausibility and validity.

*:ELEM_P_20
I:[2]
S:Make sure input doesn't violate limits of the program.

*:ELEM_P_21
I:[21]
S:Terminate input by end-of-file marker, not by count.

*:ELEM_P_22
I:[22]
S:Identify bad input; recover if possible.

*:ELEM_P_23
I:[23]
S:Make input easy to prepare and output self-explanatory.

*:ELEM_P_24
I:[24]
S:Use uniform input formats.

*:ELEM_P_25
I:[25]
S:Make input easy to proofread.

*:ELEM_P_26
I:[26]
S:Use self-identifying input.  Allow defaults.  Echo both on output.

*:ELEM_P_27
I:[27]
S:Make sure all variables are initialized before use.

*:ELEM_P_28
I:[28]
S:Don't stop at one bug.

*:ELEM_P_29
I:[29]
S:Use debugging compilers.

*:ELEM_P_30
I:[30]
S:Watch out for off-by-one errors.

*:ELEM_P_31
I:[31]
S:Take care of branch the right way on equality.

*:ELEM_P_32
I:[32]
S:Be careful if a loop exits to the same place from the middle and the bottom.

*:ELEM_P_33
I:[33]
S:Make sure your code does "nothing" gracefully.

*:ELEM_P_34
I:[34]
S:Test programs at their boundary values.

*:ELEM_P_35
I:[35]
S:Check some answers by hand.

*:ELEM_P_36
I:[36]
S:10.0 times 0.1 is hardly ever 1.0.

*:ELEM_P_37
I:[37]
S:7/8 is zero while 7.0/8.0 is not zero.

*:ELEM_P_38
I:[38]
S:Don't compare floating point numbers solely for equality.

*:ELEM_P_39
I:[39]
S:Make it right before you make it faster.

*:ELEM_P_40
I:[40]
S:Make it fail-safe before you make it faster.

*:ELEM_P_41
I:[41]
S:Make it clear before you make it faster.

*:ELEM_P_42
I:[42]
S:Don't sacrifice clarity for small gains in efficiency.

*:ELEM_P_43
I:[43]
S:Let your compiler do the simple optimizations.

*:ELEM_P_44
I:[44]
S:Don't strain to re-use code; reorganize instead.

*:ELEM_P_45
I:[45]
S:Make sure special cases are truly special.

*:ELEM_P_46
I:[46]
S:Keep it simple to make it faster.

*:ELEM_P_47
I:[47]
S:Don't diddle code to make it faster -- find a better algorithm.

*:ELEM_P_48
I:[48]
S:Instrument your programs.  Measure before making efficiency changes.

*:ELEM_P_49
I:[49]
S:Make sure comments and code agree.

*:ELEM_P_50
I:[50]
S:Don't just echo the code with comments -- make every comment count.

*:ELEM_P_51
I:[51]
S:Don't comment bad code -- rewrite it.

*:ELEM_P_52
I:[52]
S:Use variable names that mean something.

*:ELEM_P_53
I:[53]
S:Use statement labels that mean something.

*:ELEM_P_54
I:[54]
S:Format a program to help the reader understand it.

*:ELEM_P_55
I:[55]
S:Document your data layouts.

*:ELEM_P_56
I:[56]
S:Don't over comment.

Q:Do you want to continue to next lesson [Y/N] ? 
N:MENU

# ###########################################################################

*:UNIX_PRG
B:"The Art of Unix Programming", Eric S. Raymond

*:UNIX_1
I:[1]
S:Culture? What Culture?

*:UNIX_2
I:[2]
S:Unix is Fun to Hack.

*:UNIX_3
I:[3]
S:Lessons of Unix can be applied elsewhere.

*:UNIX_4
I:[4] Basics of Unix Philosophy
S:Rule of Modularity:
 :Write simple parts connected by clean interfaces.

*:UNIX_5
I:[5] Basics of Unix Philosophy
S:Rule of Clarity:
 :Clarity is better than cleverness.

*:UNIX_6
I:[6] Basics of Unix Philosophy
S:Rule of Composition:
 :Design programs to be connected with other programs.

*:UNIX_7
I:[7] Basics of Unix Philosophy
S:Rule of Separation:
 :Separate policy from mechanism; separate interfaces from engines.

*:UNIX_8
I:[8] Basics of Unix Philosophy
S:Rule of Simplicity:
 :Design for simplicity; add complexity only where you must.

*:UNIX_9
I:[9] Basics of Unix Philosophy
S:Rule of Parsimony:
 :Write a big program only when it is clear by demonstration that
 :nothing else will do.

*:UNIX_10
I:[10] Basics of Unix Philosophy
S:Rule of Transparency:
 :Design for visibility to make inspection and debugging easier.

*:UNIX_11
I:[11] Basics of Unix Philosophy
S:Rule of Robustness:
 :Robustness is the child of transparency and simplicity.

*:UNIX_12
I:[12] Basics of Unix Philosophy
S:Rule of Representation:
 :Fold knowledge into data, so program logic can be stupid and robust.

*:UNIX_13
I:[13] Basics of Unix Philosophy
S:Rule of Least Surprise:
 :In interface design, always do the least surprising thing.

*:UNIX_14
I:[14] Basics of Unix Philosophy
S:Rule of Silence:
 :When a program has nothing surprising to say, it should say nothing.

*:UNIX_15
I:[15] Basics of Unix Philosophy
S:Rule of Repair:
 :Repair when you can -- but when you must fail, fail noisily and
 :as soon as possible.

*:UNIX_16
I:[16] Basics of Unix Philosophy
S:Rule of Economy:
 :Programmer is expensive; conserve it in preference to machine time.

*:UNIX_17
I:[17] Basics of Unix Philosophy
S:Rule of Generation:
 :Avoid hand-hacking; write programs to write programs when you can.

*:UNIX_18
I:[18] Basics of Unix Philosophy
S:Rule of Optimization:
 :Prototype before polishing.  Get it working before you optimize it.

*:UNIX_19
I:[19] Basics of Unix Philosophy
S:Rule of Diversity:
 :Distrust all claims for one true way.

*:UNIX_20
I:[20] Basics of Unix Philosophy
S:Rule of Extensibility:
 :Design for the future, because it will be here sooner than you think.

*:UNIX_21
I:[21] 
S:Python language is one example.  As we noted above, it is also heavily used
 :for mathematical and scientific papers, and will probably dominate that niche
 :for some years yet.

*:UNIX_22
I:[22]
S:When the superior programmer refrains from coding, his force is felt for
 :a thousand miles.

*:UNIX_23
I:[23]
S:When you feel the urge to design a complex binary file format, or a complex
 :binary application protocol, it is generally wise to lie down until the
 :feeling passes.

*:UNIX_24
I:[24]
S:CSV (fields separated by commas, double quotes used to escape commas, 
 :no continuation lines) is rarely found under Unix.

*:UNIX_25
I:[25]
S:Use # as an introducer for comments.  It is good to have a way to embed
 :annotations and comments in data files.  It's best if they're actually part of
 :the file structure, and so will be preserved by tools that know its format.
 :For comments that are not preserved during parsing, # is the conventional start
 :character.

*:UNIX_26
I:[26] 
S:Transparency is therefore more than an esthetic triumph; it is a victory that
 :will be reflected in lower costs throughout the software's life cycle.

*:UNIX_27
I:[27] 
S:Top-down tends to be good practice when three preconditions are true:
 :(a) you can specify in advance precisely what the program is to do,
 :(b) the specification is unlikely to change significantly during implementation,
 :and (c) you have a lot of freedom in choosing, at a low level, how the program
 :is to get that job done.

*:UNIX_28
I:(28)
S:There is a flip side to this.  In the Unix world, libraries which are delivered
 :as libraries should come with exerciser programs.

*:UNIX_29
I:[29]
S:When you see the right thing, do it — this may look like more work in the short
 :term, but it's the path of least effort in the long run.  If you don't know
 :what the right thing is, do the minimum necessary to get the job done, at
 :least until you figure out what the right thing is.
 :
 :To do the Unix philosophy right, you have to be loyal to excellence.
 :You have to believe that software design is a craft worth all the intelligence,
 :creativity, and passion you can muster.  Otherwise you won't look past the easy,
 :stereotyped ways of approaching design and implementation; you'll rush into
 :coding when you should be thinking.  You'll carelessly complicate when you
 :should be relentlessly simplifying—and then you'll wonder why your code bloats
 :and debugging is so hard.

*:UNIX_30
I:[30]
S:If you have any trouble sounding condescending, find a Unix user to show you
 :how it's done.

*:UNIX_31
I:[31]
S:As with buildings, it's easier to repair superstructure on top of a solid
 :foundation than it is to replace the foundations without trashing the
 :superstructure.

*:UNIX_32
I:[32]
S:Make each program do one thing well.  To do a new job, build afresh rather
 :than complicate old programs by adding new features.

*:UNIX_33
I:[33]
S:The nightmare scenario is one in which corporate monopolism and statist
 :power-seeking, always natural allies, feed back into each other and create
 :rationales for increasing regulation, repression, and criminalization of
 :digital speech.

*:UNIX_34
I:[34]
S:To design for compactness and orthogonality, start from zero.
 :Zen teaches that attachment leads to suffering; experience with software
 :design teaches that attachment to unnoticed assumptions leads to
 :non-orthogonality, noncompact designs, and projects that fail or become
 :maintenance nightmares.

*:UNIX_35
I:[35]
S:Web pages get bogged down in the dispute over whether the reader or author
 :should control the appearance.

*:UNIX_36
I:[36]
S:To design the perfect anti-Unix, write an operating system that thinks it knows
 :what you're doing better than you do.  And then adds injury to insult by getting
 :it wrong.

*:UNIX_37
I:[37]
S:One of the main lessons of Zen is that we ordinarily see the world through
 :a haze of preconceptions and fixed ideas that proceed from our desires.
 :To achieve enlightenment, we must follow the Zen teaching not merely to let go
 :of desire and attachment, but to experience reality exactly as it is —- without
 :the preconceptions and the fixed ideas getting in the way.

*:UNIX_38
I:[38]
S:Tools that look glossy but shatter under stress are not good long-term value.

*:UNIX_39
I:[39]
S:Rushing to optimize before the bottlenecks are known may be the only error to
 :have ruined more designs than feature creep.  From tortured code to incomprehen-
 :sible data layouts, the results of obsessing about speed or memory or disk usage
 :at the expense of transparency and simplicity are everywhere.  They spawn
 :innumerable bugs and cost millions of man-hours—often, just to get marginal
 :gains in the use of some resource much less expensive than debugging time.
 :Disturbingly often, premature local optimization actually hinders global
 :optimization (and hence reduces overall performance).  A prematurely optimized
 :portion of a design frequently interferes with changes that would have much
 :higher payoffs across the whole design, so you end up with both inferior
 :performance and excessively complex code.

*:UNIX_40
I:[40]
S:Mixing languages is better than writing everything in one, if and only if
 :using only that one is likely to overcomplicate the program.

*:UNIX_41
I:[41]
S:Are the individual functions in your modules too large? 
 :
 :This is not so much a matter of line count as it is of internal complexity.
 :If you can't informally describe a function's contract with its callers in
 :one line, the function is probably too large.
 :
 :Many years ago, I learned from Kernighan & Plauger's "The Elements of
 :Programming Style" a useful rule.  Write that one-line comment immediately
 :after the prototype of your function.  For every function, without exception.

Q:Do you want to continue to next lesson [Y/N] ? 
N:MENU

# ###########################################################################

*:LISP
B:Quotes on Lisp and Functional Programming Languages

*:L1_1
I:[1] Marvin Minsky
S:Anyone could learn Lisp in one day, except that if they
 :already knew Fortran, it would take three days.

*:L1_2
I:[2] John Fraser
S:Lisp is the red pill.

*:L1_3
I:[3] Alan Kay, on Lisp
S:The greatest single programming language ever designed.

*:L1_4
I:[4] Douglas Hofstadter, "Godel, Escher, Bach"
S:One of the most important and fascinating of all computer
 :languages is Lisp (standing for "List Processing"), which was
 :invented by John McCarthy around the time Algol was invented.

*:L1_5
I:[5] John Foderaro, CACM, September 1991
S:Lisp is a programmable programming language.

*:L1_6
I:[6] John McCarthy, "Early History of Lisp"
S:One can even conjecture that Lisp owes its survival
 :specifically to the fact that its programs are lists, which
 :everyone, including me, has regarded as a disadvantage.

*:L1_7
I:[7] Alan Kay
S:Lisp isn't a language, it's a building material.

*:L1_8
I:[8] Philip Greenspun
S:Greenspun's Tenth Rule of Programming: 
 :Any sufficiently complicated C or Fortran program contains an ad hoc
 :informally-specified bug-ridden slow implementation of half of Common Lisp.

*:L1_9
I:[9] Eric Raymond, "How to Become a Hacker"
S:Lisp is worth learning for the profound enlightenment
 :experience you will have when you finally get it;
 :That experience will make you a better programmer for the rest
 :of your days, even if you never actually use Lisp itself a lot.

*:L1_10
I:[10] Yukihiro 'Matz' Matsumoto, LL2
S:Some may say Ruby is a bad rip-off of Lisp or Smalltalk,
 :and I admit that.  But it is nicer to ordinary people.

*:L1_11
I:[11] Guy Steele, Java spec co-author
S:We were not to win over the Lisp programmers;
 :we were after the C++ programmers.  We managed to drag
 :a lot of them about halfway to Lisp.

*:L1_12
I:[12] Edsger Dijkstra, CACM, 15:10
S:Lisp has jokingly been called "the most intelligent way to
 :misuse a computer".  I think that description is a great
 :compliment because it transmits the full flavor of liberation:
 :it has assisted a number of our most gifted fellow humans
 :in thinking previously impossible thoughts.

*:L1_13
I:[13] Martin Rodgers (first said by Chuck Moore about Forth)
S:Lisp is a programmer amplifier.

*:L1_14
I:[14] L. Peter Deutsch
S:Lisp... made me aware that software could be close to executable mathematics.

*:L1_15
I:[15] Winston & Horn, "Lisp"
S:Common Lisp, a happy amalgam of the features of previous Lisps.

*:L1_16
I:[16] Scott Fahlman
S:Common Lisp is politics, not art.

*:L1_17
I:[17] Eric Raymond, in "Open Sources" on MIT's first OS, ITS
S:Lisp was far more powerful and flexible than any other language of its day;
 :in fact, it is still a better design than most languages of today,
 :twenty-five years later.  Lisp freed ITS's hackers to think in unusual
 :and creative ways.  It was a major factor in their success, and remains
 :one of hackerdom's favorite languages.

*:L1_18
I:[18] Philip Greenspun
S:SQL, Lisp, and Haskell are the only languages that I've seen
 :where one spends more time thinking than typing.

*:L1_19
I:[19] A guy on Slashdot. What theory fits this data?
S:I have heard more than one Lisp advocate state such subjective comments as,
 :"Lisp is the most powerful and elegant programming language in the world"
 :and expect such comments to be taken as objective truth.  I had never
 :heard a Java, C++, C, Perl, or Python advocate make the same claim about
 :their own language of choice.

*:L1_20
I:[20] Robert Floyd, Turing Award Lecture, 1979
S:Although my own previous enthusiasm has been for syntactically rich languages,
 :like the Algol family, I now see clearly and concretely the force of Minsky's
 :1970 Turing Lecture, in which he argued that Lisp's uniformity of structure
 :and power of self reference gave the programmer capabilities whose content
 :was well worth the sacrifice of visual form.

*:L1_21
I:[21] Michael Feathers
S:Object oriented programming makes code understandable by encapsulating moving
 :parts.  Functional programming makes code understandable by minimizing moving
 :parts.

*:L1_22
I:[22] Audrey Tang
S:Haskell is faster than C++, more concise than Perl, more regular than Python,
 :more flexible than Ruby, more typeful than C#, more robust than Java, and has
 :absolutely nothing in common with PHP.

*:L1_23
I:[23] Peter Seibel
S:Consequently, a Common Lisp program tends to provide a much clearer mapping
 :between your ideas about how the program works and the code you actually write.
 :Your ideas aren't obscured by boilerplate code and endlessly repeated idioms.
 :This makes your code easier to maintain because you don't have to wade through
 :reams of code every time you need to make a change.

*:L1_24
I:[24] Simon Thompson, "Haskell: The Craft of Functional Programming"
S:Haskell programs are easy to parallelize, and to run efficiently on multicore
 :hardware, because there is no state to be shared between different threads.

*:L1_25
I:[25] Robert C. Martin
S:You don't need semaphores if you don't have side effects! You can't have
 :concurrent update problems if you don't update!
 :
 :So that's the big deal about functional languages; and it is one big fricking
 :deal.  There is a freight train barreling down the tracks towards us, with
 :multi-core emblazoned on it; and you'd better be ready by the time it gets here.

*:L1_26
I:[26] John Carmack
S:Programming in a functional style makes the state presented to your code
 :explicit, which makes it much easier to reason about, and, in a completely
 :pure system, makes thread race conditions impossible.

*:L1_27
I:[27] Joe Armstrong, "Programming Erlang"
S:Processes share no data with other processes.  This is the reason why we can
 :easily distribute Erlang programs over multicores or networks.

*:L1_28
I:[28] Martin Odersky
S:non-determinism = parallel processing + mutable state

*:L1_29
I:[29] Wikipedia
S:In computer science, functional programming is a programming paradigm -
 :a style of building the structure and elements of computer programs -
 :that treats computation as the evaluation of mathematical functions and avoids
 :changing-state and mutable data.
 :
 :(By contrast) Imperative programming is a programming paradigm that uses
 :statements that change a program's state.

*:L1_30
I:[30] Marry Rose Cook, "A Practical Introduction to Functional Programming (article)"
S:When people talk about functional programming, they mention a dizzying number
 :of 'functional' characteristics.  They mention immutable data, first class
 :functions, and tail call optimisation.  These are language features that aid
 :functional programming.

*:L1_31
I:[31] Marry Rose Cook, continue from previous
S:(Continue) They mention mapping, reducing, pipelining, recursing, currying and
 :the use of higher order functions.  These are programming techniques used to
 :write functional code.
 :
 :They mention parallelization, lazy evaluation, and determinism.  These are
 :advantageous properties of functional programs.

*:L1_32
I:[32] Marry Rose Cook, continue from previous
S:(Continue) Ignore all that.  Functional code is characterised by one thing:
 :the absence of side effects.  It (a pure function) doesn't rely on data outside
 :the current function, and it doesn't change data that exists outside the
 :current function.  Every other 'functional' thing can be derived from this
 :property.  Use it as a guide rope as you learn.

*:L1_33
I:[33] Marry Rose Cook, continue from previous
S:Functional code is characterised by one thing: the absence of side effects.

*:L1_34
I:[34] Alvin Alexander
S:Functional programming is a way of writing software applications using only
 :pure functions and immutable values.

Q:Do you want to continue to next lesson [Y/N] ? 
N:MENU

# ###########################################################################

*:LISP_2
B:Quotes on Lisp and Functional Programming Languages, Continued

*:L2_1
I:[1] Paul Graham, Nov 1983
S:I suppose I should learn Lisp, but it seems so foreign.

*:L2_2
I:[2] Found on com.lang.lisp
S:Will write code that writes code that writes code for money.

*:L2_3
I:[3] Kent Pitman
S:Lisp is a language for doing what you've been told is impossible.

*:L2_4
I:[4] Paul Graham
S:Within a couple weeks of learning Lisp I found programming in any other
 :language unbearably constraining.

*:L2_5
I:[5] Paul Graham
S:Historically, languages designed for other people to use have been bad:
 :Cobol, PL/I, Pascal, Ada, C++.  The good languages have been those that
 :were designed for their own creators: C, Perl, Smalltalk, Lisp.

*:L2_6
I:[6] Glenn Ehrlich
S:Programming in Lisp is like playing with the primordial forces of the universe.
 :It feels like lightning between your fingertips.  No other language even 
 :feels close.

*:L2_7
I:[7] Svein Ove Aas
S:The language God would have used to implement the Universe.

*:L2_8
I:[8] Christian Lynbech
S:Lisp is the most sophisticated programming language I know.  It is literally
 :decades ahead of the competition ... it is not possible (as far as I know)
 :to actually use Lisp seriously before reaching the point of no return.

*:L2_9
I:[9] Alan Kay
S:I finally understood that half page of code on the bottom of page 13 of the
 :Lisp 1.5 manual was Lisp in itself.  These were "Maxwell's Equations of
 :Software!".

*:L2_10
I:[10] Larry Wall
S:Lisp has all the visual appeal of oatmeal with fingernail clippings mixed in.
 :(Other than that, it's quite a nice language).

*:L2_11
I:[11] Alan Perlis, in foreward of SICP
S:Pascal is for building pyramids -- imposing, breathtaking, static structures
 :built by armies pushing heavy blocks into places.  Lisp is for building 
 :organisms -- imposing, breaktaking, dynamic structures built by squads
 :fitting fluctuating myriads of simpler organisms into place.

*:L2_12
I:[12] Richard Stallman
S:The most powerful programming language is Lisp.  If you don't know Lisp (or its
 :variant, Scheme), you don't appreciate what a powerful language is.  Once you
 :learn Lisp you will see what is missing in most other languages.

*:L2_13
I:[13] Larry Wall
S:By policy, Lisp has never really catered to mere mortals.  And, of course,
 :mere mortals have never really forgiven Lisp for not catering to them.

*:L2_14
I:[14] Joel Moses
S:APL is like a beautiful diamond - flawless, beautifully symmetrical.
 :But you can't add anything to it.  If you try to glue on another diamond,
 :you don't get a bigger diamond.  Lisp is like a ball of mud.  Add more
 :and it's still a ball of mud - it's still looks like Lisp.

*:L2_15
I:[15] Erik Naggum
S:Common Lisp people seem to behave in a way that is akin to the Borg:
 :they study the various new things that people do with interest and then
 :find that it was eminently doable in Common Lisp all along and they can
 :use these new techniques if they think they need them.

*:L2_16
I:[16] Alan Perlis
S:A Lisp programmer knows the value of everything, but the cost of nothing.

*:L2_17
I:[17] amz
S:If programming languages were religions ...
 :
 :Lisp would be Zen Buddhism - There is no syntax, there is no centralization
 :of dogma, there are no deities to worship.  The entire universe is there at
 :your reach - if only you are enlightened enough to grasp it.  Some say that
 :it's not a language at all; others say that it's the only language that
 :make sense.

*:L2_18
I:[18] Anonymous
S:LISP stands for: Lots of Insane Stupid Parentheses.
 :LISP stands for: Lots of Irritating Superfluous Parentheses.

*:L2_19
I:[19] Peter Norvig
S:In Lisp, if you want to do aspect-oriented programming, you just do a
 :bunch of macros and you're there.  In Java, you have to get Gregor Kiczales
 :to go out and start a new company, taking months and years and try to get
 :that to work.  Lisp still has the advantage there, it's just a question
 :of people wanting that.

*:L2_20
I:[20] Paul Graham
S:The more of an IT flavor the job descriptions had, the less dangerous was the
 :company.  The safest kind were the ones that wanted Oracle experience.  You
 :never had to worry about those.  You were also safe if they said they wanted
 :C++ or Java developers.  If they wanted Perl or Python programmers, that would
 :be a bit frightening.  If I had ever seen a job posting looking for Lisp
 :hackers, I would have been really worried.

*:L2_21
I:[21] Paul Graham, "ANSI Common Lisp"
S:The spirit of Lisp hacking can be expressed in two sentences.
 :Programming should be fun.  Programs should be beautiful.

*:L2_22
I:[22] Philip Wadler, "How to declare an imperative"
S:Whereas some declarative programmers only pay lip service to equational
 :reasoning, users of functional languages exploit them every time they run a
 :compiler, whether they notice it or not.

*:L2_23
I:[23] Robin Milner
S:There are many ways of trying to understand programs.  People often rely too
 :much on one way, which is called 'debugging' and consists of running a
 :partly-understood program to see if it does what you expected.  Another way,
 :which ML advocates, is to install some means of understanding in the very
 :programs themselves.

*:L2_24
I:[24] Alvin Alexander
S:The best FP code is like algebra, and in algebra you never re-use variables.
 :And not re-using variables has many benefits.

*:L2_25
I:[25] Bartos Milewski
S:Did you notice that in the definition of 'data race'
 :there's always talk of mutation?

*:L2_26
I:[26] defmacro
S:A functional program is ready for concurrency without any further modifications.
 :You never have to worry about deadlocks and race conditions because you don't
 :need to use locks.  No piece of data in a functional program is modified twice
 :by the same thread, let alone by two different threads.  That means you can
 :easily add threads without ever giving conventional problems that plague
 :concurrency applications a second thought.

*:L2_27
I:[27] Jon Fairbairn
S:By the way seriously: how do you debug Haskell programs?
 :
 :Mostly seriously: I don't.  If the programme doesn't work the way I intended it,
 :I rewrite bits in a simpler fashion until I understand it well enough and it
 :works.  For the sort of programme you were asking for, breaking things up until
 :they are small enough that one can understand the individual parts completely
 :(as I did in the solution I posted) and then composing them together really is
 :the best approach.
 :
 :If you need to debug a programme that simple, what it's telling you is that
 :you've written it the wrong way!

*:L2_28
I:[28] Audrey Tang
S:I think Haskell excels at everything but user base :)

*:L2_29
I:[29] Audrey Tang
S:Perl: "Easy things are easy, hard things are possible."
 :Haskell: "Hard things are easy, the impossible just happened."

*:L2_30
I:[30] Collection of "Shoot Yourself in the Foot with Haskell"
S:You shoot the gun, but the bullet gets trapped in the IO monad.
 :
 :Couldn't match expected type 'Deer' against inferred type 'Foot'.
 :
 :The bullet is in the ST monad and the gun is in the IO monad, so you can't.
 :
 :You are perfectly fine as long as you just don't evaluate the foot.
 :
 :Nothing happens unless you start walking.

*:L2_31
I:[31] Stephen Wolfram
S:The fact that the same symbolic programming primitives work for those as work
 :for math kinds of things, I think, really validates the idea of symbolic
 :programming being something pretty general.


Q:Do you want to continue to next lesson [Y/N] ? 
N:MENU

# ###########################################################################

*:C_CPP
B:C and its family (C++, Objective-C)

*:C_1
I:[1] Mike Vanier
S:If I had a nickel for every time I've written "for (i = 0; i < N; i++)" in C
 :I'd be a millionaire.

*:C_2
I:[2] Richard A. O'Keefe
S:Fifty years of programming language research, and we end up with C++?

*:C_3
I:[3] Bob Gray
S:Writing in C or C++ is like running a chain saw with all the safety
 :guards removed.

*:C_4
I:[4] Bjarne Stroustrup
S:C makes it easy to shoot yourself in the foot; C++ makes it harder,
 :but when you do, you blow off your whole leg.

*:C_5
I:[5] Gavin Russell Baker
S:C++: Where friends have access to your private members.

*:C_6
I:[6] Waldi Ravens.
S:A C program is like a fast dance on a newly waxed dance floor by people
 :carrying razors.

*:C_7
I:[7] Ron Sercely.
S:The evolution of languages: Fortran is a non-typed language.  C is a weakly
 :typed language.  Ada is a strongly typed language.  C++ is a strongly hyped
 :language.

*:C_8
I:[8] Alan Kay
S:I invented the term 'Object-Oriented', and I can tell you I did not have C++
 :in mind. 

*:C_9
I:[9] David Jameson
S:The latest new features in C++ are designed to fix the previously new features
 :in C++.

*:C_10
I:[10] Anonymous
S:I have yet to meet a C compiler that is more friendly and easier to use
 :than eating soup with a knife.

*:C_11
I:[11] Ray Simard
S:C /n./: A programming language that is sort of like Pascal except more like
 :assembly except that it isn't very much like either one, or anything else.
 :It is either the best language available to the art today, or it isn't.

*:C_12
I:[12] Blair P. Houghton
S:In My Egotistical Opinion, most people's C programs should be indented
 :six feet downward and covered with dirt.

*:C_13
I:[13] J.P. Candusso
S:Going from programming Pascal to programming in C, is like learning to write
 :in Morse code.

*:C_14
I:[14] Shakespeare
S:#define QUESTION ((bb) || !(bb))

*:C_15
I:[15] Kernighan
S:C is not a high-level language.

*:C_16
I:[16] Elon Musk
S:I like C, because it avoids class warfare.

*:C_17
I:[17] Dennis M. Ritchie
S:C is quirky, flawed, and an enormous success.

*:C_18
I:[18] Linus Torvalds
S:C++ is a horrible language.  It's made more horrible by the fact that a lot
 :of substandard programmers use it, to the point where it's much much easier to
 :generate total and utter crap with it.  Quite frankly, even if the choice of C
 :were to do *nothing* but keep the C++ programmers out, that in itself would
 :be a huge reason to use C.

*:C_19
I:[19] Scott Meyers on friends functions in C++
S:Friends, much as in real life, are often more trouble than their worth.

*:C_20
I:[20] James Hague
S:PL/I and Ada started out with all the bloat, were very daunting languages,
 :and got bad reputations (deservedly).  C++ has shown that if you slowly bloat
 :up a language over a period of years, people don't seem to mind as much.

*:C_21
I:[21] Stefan Van Baelen
S:C(++) is a write-only, high-level assembler language.

*:C_22
I:[22] Michael B. Feldman
S:C++ would make a decent teaching language if we could teach the ++ part
 :without the C part.

*:C_23
I:[23] Larry O'Brien
S:From a practical viewpoint, it's easy to see that C will always be with us,
 :taking a place beside Fortran and COBOL as the right tool for certain jobs.

*:C_24
I:[24] Bertrand Meyer
S:C++ is the only current language making COBOL look good.

*:C_25
I:[25] Bill Joy
S:You can't prove anything about a program written in C or Fortran.
 :It's really just Peek and Poke with some syntactic sugar.

*:C_26
I:[26] Philip Greenspun
S:Any sufficiently complicated C or Fortran program contains an ad hoc
 :informally-specified bug-ridden slow implementation of half of Common Lisp.

*:C_27
I:[27] Bjarne Stroustrup
S:C++: Simula in wolf's clothing.

*:C_28
I:[28] Steve Haflich, "alt.lang.design", Dec 1994
S:(If the only tool you have is a hammer, everything begins to look like a nail)
 :When your hammer is C++, everything begins to look like a thumb.

*:C_29
I:[29] Thant Tessman, "comp.lang.scheme", Dec 1996
S:Being really good at C++ is like being really good at using rocks
 :to sharpen sticks.

*:C_30
I:[30] Guy L. Steele, "Objects have not failed.", OOPSLA 2002
S:As for C++ - well, it reminds me of the Soviet-era labor joke:
 :"They pretend to pay us, and we pretend to work."
 :
 :C++ pretends to provide an object-oriented data model, C++ programmers pretend
 :to respect it, and everyone pretends that the code will work.  The actual data
 :model of C++ is exactly that of C, a single two-dimensional array of bits,
 :eight by four billion, and all the syntactic sugar of C++ fundamentally cannot
 :mask the gapping holes in its object model left by the cast operator and
 :unconstrained address arithmetic.

*:C_31
I:[31] Bertrand Meyer
S:There are only two things wrong with C++: The initial concept and the
 :implementation.

*:C_32
I:[32] Erwin Dieterich
S:The last good thing written in C was Franz Schubert's Symphony Number 9.

*:C_33
I:[33] Larry Wall
S:The problem with using C++ ... is that there's already a strong tendency in
 :the language to require you to know everything before you can do anything.

*:C_34
I:[34] Brian Kernighan & Dennis Ritchie
S:As we said in the preface to the first edition, C wears well as one's exper-
 :ience with it grows.  With a decade more experience, we still feel that way.

*:C_35
I:[35] David Keppel
S:It has been discovered that C++ provides a remarkable facility for concealing
 :the trivial details of a program such as where its bugs are.

Q:Do you want to continue to next lesson [Y/N] ? 
N:MENU

# ###########################################################################

*:JAVACS
B:Java and C#

*:JAVACS_1
I:[1] Michael Feldman
S:Java is, in many ways, C++--.

*:JAVACS_2
I:[2] Alanna
S:Saying that Java is nice because it works on all OSes is like saying that
 :anal sex is nice because it works on all genders.

*:JAVACS_3
I:[3] Pixadel
S:Fine, Java MIGHT be a good example of what a programming language
 :should be like.  But Java applications are good examples of what
 :applications SHOULDN'T be like.

*:JAVACS_4
I:[4] Robert Sewell
S:If Java had true garbage collection, most programs would delete
 :themselves upon execution.

*:JAVACS_5
I:[5] James Gosling, co-inventor of Java
S:Java is C++ without guns, knives, and clubs.

*:JAVACS_6
I:[6] Brucee
S:Java: write once, run away!

*:JAVACS_7
I:[7] Chris Heilmann
S:Java is to JavaScript what car is to carpet.

*:JAVACS_8
I:[8] Scott Bellware
S:Java is a DSL to transforming big XML documents into long exception
 :stack traces.

*:JAVACS_9
I:[9] Tel Hudson
S:Using Java for serious jobs is like trying to take the skin off a rice pudding
 :wearing boxing groves.

*:JAVACS_10
I:[10] Bill Gates
S:Anybody who thinks a little 9,000-line program [ Java ] that's distributed
 :free and can be cloned by anyone is going to affect anything we do at
 :Microsoft has his head screwed on wrong.

*:JAVACS_11
I:[11] Scott McNealy
S:Take a cup of coffee and add three drops of poison and what have you got?
 :Microsoft J++.

*:JAVACS_12
I:[12] Paul Graham
S:Of all the programmers I can think of, I know only one who would voluntarily
 :program in Java.  And of all the great programmers I can think of who don't
 :work for Sun, on Java, I know of zero.

*:JAVACS_13
I:[13] Charles Simonyi
S:Thirty years from now nobody will remember Java and everyone will remember
 :Microsoft.

*:JAVACS_14
I:[14] Alan Kay
S:Java is the most distressing thing to happen to computing since MS-DOS.

*:JAVACS_15
I:[15] James Gosling
S:Your development cycle is much faster because Java is interpreted.
 :The compile-link-load-test-crash-debug cycle is obsolete.

*:JAVACS_16
I:[16] Scott McKay
S:C++ is history repeated as tragedy.  Java is history repeated as farce.

*:JAVACS_17
I:[17] Larry O'Brien
S:Claiming Java is easier than C++ is like saying that
 :K2 is shorter than Everest.

*:JAVACS_18
I:[18] Matthew B. Kennel
S:In the best possible scenario Java will end up mostly like Eiffel but with
 :extra warts because of insufficiently thoughtful early design.

*:JAVACS_19
I:[19] Frank Winkler
S:Java, the best argument for Smalltalk since C++.

*:JAVACS_20
I:[20] Philip Greenspun
S:Java is the SUV of programming tools.

*:JAVACS_21
I:[21] Thant Tessman, "comp.lang.scheme", Jun 2000
S:You're posting to a Scheme group.  Around here, arguing that Java is better
 :than C++ is like arguing that grasshoppers taste better than tree bark.

*:JAVACS_22
I:[22] Paul Graham
S:Like the creators of sitcoms or junk food or package tours, Java's designers
 :were consciously designing a product for people not as smart as them.

*:JAVACS_23
I:[23] Steve Holden
S:There are undoubtedly a lot of very intelligent people writing Java, better
 :programmers than I will ever be.  I just wish I knew why.

*:JAVACS_24
I:[24] Patricia Seybold in 1998
S:If you learn to program in Java, you'll never be without a job!

*:JAVACS_25
I:[25] John Knight
S:Knowing the syntax of Java does not make someone a software engineer.

*:JAVACS_26
I:[26] James Gosling
S:Over the years, I've used and created a wide variety of scripting languages,
 :and in general, I'm a big fan of them.  When the project that Java came out of
 :first started, I was originally planning to do a scripting language.  But a
 :number of forces pushed me away from that.

Q:Do you want to continue to next lesson [Y/N] ? 
N:MENU

# ###########################################################################

*:DY_SCRIPT
B:Perl, Ruby, Python, etc. Mostly scriptings languages.

*:SCRIPT_1
I:[1] Keith Bostic
S:Perl - The only language that looks the same before and after RSA encryption.

*:SCRIPT_2
I:[2] Jon Ribbens
S:PHP is a minor evil perpetrated and created by incompetent amateurs, whereas
 :Perl is a great and insidious evil perpetrated by skilled but perverted
 :professionals.

*:SCRIPT_3
I:[3] Larry Wall
S:It is easier to port a shell than a shell script.

*:SCRIPT_4
I:[4] Nikita Popov
S:Ruby is rubbish! PHP is phpantastic!

*:SCRIPT_5
I:[5] Yukihiro 'Matz' Matsumoto
S:For me the purpose of life is partly to have joy.  Programmers often feel joy
 :when they can concentrate on the creative side of programming.  So Ruby
 :is designed to make programmers happy.

*:SCRIPT_6
I:[6] Yukihiro 'Matz' Matsumoto
S:I hope to see Ruby helps every programmer in the world to be productive,
 :and to enjoy programming, and to be happy.  That is the primary purpose
 :of Ruby language.

*:SCRIPT_7
I:[7] Yukihiro 'Matz' Matsumoto
S:We just need the Turing machine to solve all our problems, in theory.
 :Humans require more sophisticated tools to program.  It's a matter of
 :human need.  As long as some people feel happy using Ruby, that's
 :enough of a reason for another language.

*:SCRIPT_8
I:[8] Anonymous
S:If you put 100 million monkeys to hammer away at keyboards for 100 million
 :years, one of them will write a C program.  The rest will write Perl.

*:SCRIPT_9
I:[9] Anonymous
S:If Python is executable pseudocode, then Perl is executable line noise.

*:SCRIPT_10
I:[10] Rasmus Lerdorf
S:I'm not a real programmer.  I throw together things until it works then
 :I move on.  The real programmers will say: "yeah it works but you're leaking
 :memory everywhere.  Perhaps we should fix that".  I'll just restart Apache
 :every 10 requests.

*:SCRIPT_11
I:[11] Teodor Zlatanov
S:If you want to shoot yourself in the foot, Perl give you ten bullets and
 :a laser scope, then stand by and cheer you on.

*:SCRIPT_12
I:[12] Yukihiro 'Matz' Matsumoto
S:Actually, I'm trying to make Ruby natural, not simple.

*:SCRIPT_13
I:[13] Xah Lee
S:The three characteristics of Perl programmers: mundaneness, sloppiness, and
 :fatuousness.

*:SCRIPT_14
I:[14] Jeffrey Davis
S:Perl has grown from being a very good scripting language into something like
 :a cross between a universal solvent and an open-ended Mandarin where new
 :ideograms are invented hourly.

*:SCRIPT_15
I:[15] Bruce Eckel
S:Perl is like vise grips.  You can do anything with it but it is the wrong
 :tool for every job.

*:SCRIPT_16
I:[16] Xah Lee
S:Perl is the sanctuary of dunces.  The godsend for brainless coders.  The means
 :and banner of sysadmins.  The lingua franca of trial-and-error hackers.  The
 :song and dance of stultified engineers.

*:SCRIPT_17
I:[17] Jeff Smith
S:Perl is a car with an autopilot designed by insane aliens.

*:SCRIPT_18
I:[18] Charlie Campbell
S:JavaScript is the duct tape of the internet.

*:SCRIPT_19
I:[19] Erik Naggum, "comp.lang.lisp", Nov 2000
S:The Perl programmer who veers off the road into the forest will get out of
 :his car and cut down each and every tree that blocks his progress, then drive
 :a few meters and repeat the whole process.  Whether he gets where he wanted
 :to go or not is immaterial - a Perl programmer will happily keep moving forward
 :and look busy.
 :
 :It's not that Perl programmers are idiots, it's that the language rewards
 :idiotic behavior in a way that no other language or tool has ever done.

*:SCRIPT_20
I:[20] G. van Rossum
S:Don't you hate code that's not properly indented? Making it [indenting] part
 :of the syntax guarantees that all code is properly indented.

*:SCRIPT_21
I:[21] Alan Kay
S:Perl is another example of filling a tiny, short-term need, and then being
 :a real problem in the longer term.

*:SCRIPT_22
I:[22] Jeff Polk
S:There's no obfuscated Perl contest because it's pointless.

*:SCRIPT_23
I:[23] Larry Wall
S:A Perl program is correct if it gets the job done before your boss fire you.

*:SCRIPT_24
I:[24] Brian Hook, about Perl
S:I have a pretty major problem with a language where one of the most common
 :variables has the name $_.

*:SCRIPT_25
I:[25] Guido van Rossum (creator of Python)
S:Now, it's my belief that Python is a lot easier than to teach to students
 :programming and teach them C or C++ or Java at the same time because all the
 :details of the languages are so much harder.  Other scripting languages really
 :don't work very well there either.

*:SCRIPT_26
I:[26] Yukihiro 'Matz' Matsumoto
S:I didn't work hard to make Ruby perfect for everyone, because you feel differently
 :from me.  No language can be perfect for everyone.  I tried to make Ruby perfect
 :for me, but maybe it's not perfect for you.  The perfect language for Guido van
 :Rossum is probably Python.

Q:Do you want to continue to next lesson [Y/N] ? 
N:MENU

# ###########################################################################

*:OOP
B:OO Designs and implementation in Languages

*:OOP_1
I:[1] Paul Graham, "Hackers & Painters: Big Ideas from the Computer Age"
S:Object-Oriented programming offers a sustainable way to write spaghetti code.
 :It lets you accrete programs as a series of patches.

*:OOP_2
I:[2] Alan Kay
S:I invented the term 'Object-Oriented', and I can tell you I did not have C++
 :in mind.

*:OOP_3
I:[3] Roberto Waltman
S:In the one and only true way.  The object-oriented version of 'Spaghetti code',
 :is, of course, 'Lasagna code'.  (Too many layers).

*:OOP_4
I:[4] Joe Armstrong, inventor of Erlang
S:The problem with object-oriented languages is that they've got all this
 :implicit environment that they carry around with them.  You wanted a banana
 :but what you've got is a gorilla holding the banana and the entire jungle.

*:OOP_5
I:[5] Anonymous
S:The great thing about Object-Oriented code is that it can make small,
 :simple problems look like a large, complex ones.

*:OOP_6
I:[6] Lasse Petersen
S:"Eiffel: The Programming Language" is certainly by far the most expensive piece
 :of fiction on my bookshelf.  Excellent, entertaining fiction, but it remains
 :fiction nevertheless.

*:OOP_7
I:[7] Ed Yourdon
S:A system composed of 100,000 lines of C++ is not be sneezed at, but we don't
 :have that much trouble developing 100,000 lines of COBOL today.  The real test
 :of OOP will come when systems of 1 to 10 million lines of code are developed.

*:OOP_8
I:[8] phluid
S:I won't program in Java anymore.  I'm not Marxist and don't believe in classes.

*:OOP_9
I:[9] Bill Joy
S:I fear that new object-oriented systems may suffer the fate of Lisp, in that
 :they can do many things, but the complexity of the class hierarchies may
 :cause them to collapse under their own weight.

*:OOP_10
I:[10] Alan Kay
S:Java is the most distressing thing to happen to computing since MS-DOS.

*:OOP_11
I:[11] Thant Tessman
S:OO is like the Bible in that which scripture is to be interpreted metaphori-
 :cally, and which is to be interpreted literally, is entirely a function of the
 :religious agenda of the commentator.  My own advice is to keep in mind that
 :the stuff of computer programs is nothing but metaphor.

*:OOP_12
I:[12] Paul Graham, "ANSI Common Lisp"
S:The object-oriented model makes it easy to build programs by accretion.
 :What this often means, in practice, is that it provides a structured way to
 :write spaghetti code.  This is not necessarily bad, but it is not entirely
 :good either.
 :
 :A lot of code in the real world is spaghetti code, and this is probably not
 :going to change soon.  For programs that would have ended up as spaghetti
 :anyway, the object-oriented model is good: they will at least be structured
 :spaghetti.  But for programs that might otherwise have avoided this fate,
 :object-oriented abstractions could be more dangerous than useful.

*:OOP_13
I:[13] Richard P. Gabriel, "Objects have failed", OOPSLA 2002
S:Bricks are just too limited, and the circumstances where they make sense are
 :too constrained to serve as a model for building something as diverse and
 :unpredictable as a city.  And further, the city itself is not the end goal,
 :because the city must also -in the best case- be a humane structure for human
 :activity, which requires a second set of levels of complexity and concerns.
 :Using this metaphor to talk about future computing systems, it's fair to say
 :that OO addresses concerns at the level of bricks.
 :
 :Despite the early clear understanding of the nature of software development by
 :OO pioneers, the current caretakers of the ideas have reverted to the incumbent
 :philosophy of perfect planning, grand design, and omniscience inherited
 :from Babbage's theology.

*:OOP_14
I:[14] Rob Pike
S:Object-oriented design is the roman numerals of computing.

*:OOP_15
I:[15] D. Gelernter, "Machine Beauty"
S:Object-oriented programming as it emerged in Simula 67 allows software
 :structure to be based on real-world structures, and gives programmers a
 :powerful way to simplify the design and construction of complex programs.

*:OOP_16
I:[16] Bertrand Meyer, "ITWorld.com"
S:All I can really say by way of a reasonably short comment is that inheritance
 :is a very flexible mechanism.  It's possible and in fact fairly common to misuse
 :it, but that's not a reason to distrust it systematically as seems to have
 :become the fashion.

*:OOP_17
I:[17] Bertrand Meyer, "ITWorld.com"
S:One problem I have with a good deal of the literature is that it is based on
 :a view of inheritance strongly or even solely determined by knowledge of the
 :mechanisms of C++ and Java.  I think that to understand the scope of inheritance
 :one must look beyond these two languages, which are each the products of a
 :specific time, a specific frame of mind, a specific market, and a specific
 :frame of mind. One should learn from them but not be restricted by their view
 :of the world. 

*:OOP_18
I:[18] Charles Petzold, "Programming MS Windows with C#"
S:In a sense, the whole history of new programming languages and class libraries
 :for Windows has involved the struggle to reduce the windows hello-world program
 :down to something small, sleek, and elegant.

*:OOP_19
I:[19] Paul Graham
S:The object-oriented model makes it easy to build up programs by accretion.
 :What this often means, in practice, is that it provides a structured way to
 :write spaghetti code.

*:OOP_20
I:[20] Bjarne Stroustrup
S:Certainly not every good program is object-oriented,
 :and not every object-oriented program is good.

*:OOP_21
I:[21] Edsger Dijkstra
S:Object-Oriented programming is an exceptionally bad idea which could have
 :originated in California.

*:OOP_22
I:[22] James H. Clark
S:It's very hard to explain to people who don't program, but the object-oriented
 :programming system made programming the Mac and iPhone so easy.

Q:Do you want to continue to next lesson [Y/N] ? 
N:MENU

# ###########################################################################

*:LEGACY
B:Older, Legacy Languages: COBOL, Fortran, etc

*:LEGACY_1
I:[1] Edsger W. Dijkstra
S:The use of COBOL cripples the mind; its teaching should therefore be regarded
 :as a criminal offense.

*:LEGACY_2
I:[2] Edsger W. Dijkstra
S:It is practically impossible to teach good programming style to students
 :that have had prior exposure to BASIC.  As potential programmers, they are
 :mentally mutilated beyond hope of regeneration.

*:LEGACY_3
I:[3] C.A.R Hoare, for Algol 60 (then taken in C)
S:I couldn't resist the temptation to put in a null reference, simply because
 :it was so easy to implement.  This has led to innumerable errors,
 :vulnerabilities, and system crashes, which have probably caused a billion
 :dollars of pain and damage in the last forty years.

*:LEGACY_4
I:[4] Alan J. Perlis
S:Fortran is not a flower but a weed -- it is hardy, occasionally blooms,
 :and grows in every computer.

*:LEGACY_5
I:[5] Edsger W. Dijkstra
S:Fortran, the infantile disorder, by now nearly 20 years old, is hopelessly
 :inadequate for whatever computer application you have in mind today:
 :it is now too clumsy, too risky, and too expensive to use.

*:LEGACY_6
I:[6] Ken Thompson, co-creator of B, Unix, Go
S:Fortran was the language of choice for the same reason that three-legged
 :races are popular.

*:LEGACY_7
I:[7] Anonymous
S:COBOL: Completely Obsolete Business Orientated Language.

*:LEGACY_8
I:[8] Anonymous
S:Erroneous COBOL programs were often referred to as 'pregnant programs'
 :because the issue was usually due to missed periods.

*:LEGACY_9
I:[9] Anonymous
S:COBOL programmers understand why women hate periods.

*:LEGACY_10
I:[10] Edsger W. Dijkstra
S:In the good old days physicists repeated each other's experiments, just
 :to be sure.  Today they stick to Fortran, so that they can share each other's
 :programs, bugs included.

*:LEGACY_11
I:[11] Robert Glass
S:COBOL is a very bad language, but all the others (for business data processing)
 :are so much worse.

*:LEGACY_12
I:[12] Ed Post
S:As long as there are ill-defined goals, bizarre bugs, and unrealistic
 :schedules, there will be Real Programmers willing to jump in and Solve The
 :Problem, saving the documentation for later.  Long live Fortran!

*:LEGACY_13
I:[13] Larry Wall
S:I knew I'd hate COBOL the moment I saw they'd used 'perform' instead of 'do'.

*:LEGACY_14
I:[14] Charles Petzold
S:COBOL has almost no fervent enthusiasts.  As a programming tool, it has roughly
 :the sex appeal of a wrench.

*:LEGACY_15
I:[15] Steven Feiner
S:You can tell how far we have to go, when Fortran is the language of
 :supercomputers.

*:LEGACY_16
I:[16] John Krueger
S:A computer without COBOL and Fortran is like a piece of chocolate cake without
 :ketchup or mustard.

*:LEGACY_17
I:[17] Edsger W. Dijkstra
S:COBOL is for morons.

*:LEGACY_18
I:[18] Edsger W. Dijkstra
S:With respect to COBOL you can really do only one or two things: fight the
 :disease or pretend that it does not exist.

*:LEGACY_19
I:[19] Peter Gabriel
S:The very architecture of almost every computer today is designed to optimize
 :the performance of Fortran programs and its operating-system-level sister, C.

*:LEGACY_20
I:[20] Jargon File
S:COBOL: (Synonymous with evil.): A weak, verbose, and flabby language used by
 :card wallopers to do boring mindless things on dinosaur mainframes.

*:LEGACY_21
I:[21] Bertrand Meyer
S:COBOL programmers are destined to code COBOL for the rest of their lives,
 :and thereafter.

*:LEGACY_22
I:[22] Ed Post
S:If you can't do it in Fortran, do it in assembly language.  If you can't do it
 :in assembly language, it isn't worth doing.

*:LEGACY_23
I:[23] Edsger W. Dijkstra
S:Using PL/I must be like flying a plane with 7,000 buttons, switches, and
 :handles to manipulate in the cockpit.

*:LEGACY_24
I:[24] Edsger W. Dijkstra
S:When Fortran has been called infantile disorder, PL/I, with its growth
 :characteristics of a dangerous tumor, could turn out to be a fatal disease.

*:LEGACY_25
I:[25] Edsger W. Dijkstra
S:PL/I, "the fatal disease", belongs more to the problem set than
 :to the solution set.

*:LEGACY_26
I:[26] Bruce Powel Douglass
S:C treats you like a consenting adult.  Pascal treats you like a naughty child.
 :Ada treats you like a criminal.

*:LEGACY_27
I:[27] Bill Joy
S:There are a couple of people in the world who can really program in C or
 :Fortran.  They write code in less time than it takes for other programmers.
 :Most programmers aren't that good.  The problem is that those few programmers
 :who crank out code aren't interested in maintaining it.

*:LEGACY_28
I:[28] Edsger W. Dijkstra
S:APL is a mistake, carried through to perfection.  It is the language of the
 :future for the programming techniques of the past: it creates a new generation
 :of coding bums. 

*:LEGACY_29
I:[29] John C. Reynolds
S:Another line of development stemming from Algol 60 has led to languages such as
 :Pascal and its descendants, e.g. Euclid, Mesa, and Ada, which are significantly
 :lower level than Algol.  Each of these languages seriously restricts the block
 :or procedure mechanism of Algol by eliminating features such as call by name,
 :dynamic arrays, or procedure parameters.

*:LEGACY_30
I:[30] Henry Spencer
S:Programming graphics in X is like finding the square root of PI
 :using Roman numerals.

Q:Do you want to continue to next lesson [Y/N] ? 
N:MENU

# ###########################################################################

*:FUNNY
B:Funny but True about Programmers/Programming

*:FUNNY_1
I:[1] Rick Cook, The Wizardry Compiled
S:Programming today is a race between software engineers striving to build
 :bigger and better idiot-proof programs, and the Universe trying to produce
 :bigger and better idiots.  So far, the Universe is winning.

*:FUNNY_2
I:[2] Larry Wall
S:Most of you are familiar with the virtues of a programmer.
 :There are three, of course: laziness, impatience, and hubris.

*:FUNNY_3
I:[3] Seymour Cray
S:The trouble with programmers is that you can never tell what a programmer
 :is doing until it's too late.

*:FUNNY_4
I:[4] Larry Niven
S:That's the thing about people who think they hate computers.
 :What they really hate is lousy programmers.

*:FUNNY_5
I:[5] Bill Bryson
S:For a long time it puzzled me how something so expensive, so leading edge,
 :could be so useless.  And then it occurred to me that a computer is a stupid
 :machine with the ability to do incredibly smart things, while computer
 :programmers are smart people with ability to do incredibly stupid things.
 :They are, in short, a perfect match.

*:FUNNY_6
I:[6] Peter Seebach
S:A hacker on a roll may be able to produce - in a period of a few months -
 :something that a small development group (say 7-8 people) would have a hard
 :time getting together over a year.  IBM used to report that certain
 :programmers might be as much as 100 times as productive as other workers,
 :or more.

*:FUNNY_7
I:[7] Randall E. Stross
S:The best programmers are not marginally better than merely good ones.
 :They are an order-of-magnitude better, measured by whatever standard:
 :conceptual creativity, speed, ingenuity of design, or problem-solving ability.

*:FUNNY_8
I:[8] Bill Gates
S:A great lathe operator commands several times the wage of an average lathe
 :operator, but a great writer of software code is worth 10,000 times the price
 :of an average software writer.

*:FUNNY_9
I:[9] Mosher's Law of Software Engineering
S:Don't worry if it doesn't work right.
 :If everything did, you'd be out of a job.

*:FUNNY_10
I:[10] Bill Gates
S:Measuring programming progress by lines of code is like measuring aircraft
 :building progress by weight.

*:FUNNY_11
I:[11] George Carrette
S:First learn computer science and all the theory.
 :Next develop a programming style.
 :Then forget all that and just hack.

*:FUNNY_12
I:[12] John Johnson
S:First, solve the problem.  Then, write the code.

*:FUNNY_13
I:[13] Larry Flon
S:There is no programming language - no matter how structured - that will
 :prevent programmers from making bad programs.

*:FUNNY_14
I:[14] Richard Pattis
S:When debugging, novices insert corrective code; experts remove defective code.

*:FUNNY_15
I:[15] Kent Beck
S:Optimism is an occupational hazard of programming; feedback is the treatment.

*:FUNNY_16
I:[16] Oktal
S:I think Microsoft named .Net so it wouldn't show up in a Unix directory listing.

*:FUNNY_17
I:[17] Jessica Gaston
S:One man's crappy software is another man's full-time job.

*:FUNNY_18
I:[18] Anonymous
S:It's not a bug -- it's an undocumented feature.

*:FUNNY_19
I:[19] Doug Linder
S:A good programmer is someone who always looks both ways before crossing
 :one-way street.

*:FUNNY_20
I:[20] Anonymous
S:Why do programmers prefer dark mode?
 :Cause light attracts bugs.

*:FUNNY_21
I:[21] Jerry Ogdin
S:A debugged program is one for which you have not yet found the conditions
 :that make it fail.

*:FUNNY_22
I:[22] Anonymous
S:Debugging is being a detective in a crime story
 :where you are also the murderer.

*:FUNNY_23
I:[23] Anonymous
S:99 little bugs in the code.
 :99 little bugs in the code.
 :Take one down, patch it around.
 :127 little bugs in the code...

*:FUNNY_24
I:[24] Bill Pfeifer
S:If it works, leave it alone -- there's no need to understand it.
 :If it fails, try to fix it -- there's no time to understand it.

*:FUNNY_25
I:[25] Christopher Thompson
S:Sometimes it pays to stay in bed on Monday, rather than spending the rest
 :of the week debugging Monday's code.

*:FUNNY_26
I:[26] Anonymous
S:My software never has bugs.  It just develops random features.

*:FUNNY_27
I:[27] Anonymous
S:The only difference between a bug and a feature is the documentation.

*:FUNNY_28
I:[28] Anonymous
S:Assumption is the mother of all fuckups.

*:FUNNY_29
I:[29] J. Horning
S:Computer Science is the only discipline in which we view adding a new wing
 :to a building as being maintenance.

*:FUNNY_30
I:[30] Anonymous
S:All computers wait at the same speed.

*:FUNNY_31
I:[31] Anonymous
S:Artificial Intelligence usually beats natural stupidity.

*:FUNNY_32
I:[32] Miguel de Icaza
S:Every piece of software written today is likely going to infringe on someone
 :else's patent.

*:FUNNY_33
I:[33] Anonymous
S:Good programming is 99% sweat and 1% coffee.

*:FUNNY_34
I:[34] Jeff Atwood
S:The older I get, the more I believe that the only way to become a better
 :programmer is by not programming.

*:FUNNY_35
I:[35] Bruce Ediger
S:The only "intuitive" interface is the nipple.  After that it's all learned.

*:FUNNY_36
I:[36] Larry Wall
S:Real programmers can write assembly code in any language.

*:FUNNY_37
I:[37] Jeff Atwood
S:No one hates software more than software developers.

*:FUNNY_38
I:[38] Anonymous
S:Developer: an organism that turns coffee into code.

*:FUNNY_39
I:[39] Anonymous
S:There's no test like production.

*:FUNNY_40
I:[40] Anonymous
S:There is nothing quite so permanent as a quick fix.

*:FUNNY_41
I:[41] Paul Leary
S:That's what's cool about working with computers.  They don't argue, they
 :remember everything, and they don't drink all your beer.

*:FUNNY_42
I:[42] Kathy Griffin
S:I also love Mole, the unsung hero of reality programming.

*:FUNNY_43
I:[43] Craig Bruce
S:Yeah, computers are going to take over the programming business because they
 :have become so fast recently that they can solve the Halting Problem in five
 :seconds flat.

*:FUNNY_44
I:[44] Gerald Weinberg
S:Writing code has a place in the human hierarchy worth somewhere above grave robbing
 :and beneath managing.

# for the last lesson, no question asked, just goto menu
G:MENU
